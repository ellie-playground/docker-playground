# 5.1 레지스트리, 리포지터리, 이미지 태그 다루기

도커 이미지에는 이름이 부여되는데, 이 이름에 해당 이미지를 내려받기 위해 필요한 모든 정보가 들어 있다. 지금까지 우리가 사용했던 이미지는 `image-gallery`나 `diamol/golang` 처럼 하나 혹은 두 개의 요소로 구성되는 간단한 이름을 가졌다. 그러나 이미지의 전체 이름은(이미지 참조 라고도 부른다) 네 개의 요소로 구성된다.

<aside>
💡

docker.io/diamol/golang:latest

</aside>

# 5.3 나만의 도커 레지스트리 운영하기

로컬 네트워크에 전용 레지스크리가 있으면 편리한 점이 많다. 도커 코어 레지스트리 서버는 깃허브 저장소 `docker/distribution`에서 개발이 진행된다. 코어 레지스트리 서버는 도커 허브와 동일한 레이어 캐시 시스템을 통해 이미지를 내려받고 푸시하는 기본적인 기능을 제공한다. 그러나 도커 허브에서 볼 수 있는 웹 기반 UI 등의 기능은 빠져 있다. 코어 레지스트리 서버는 매우 가볍게 동작하는 서버로, 내가 별도로 `diamol` 계정에 패키징한 이미지를 사용해 컨테이너 형태로 직접 실행할 수 있다.

```docker
root@ip-172-31-0-13:/home/ubuntu# docker container run -d -p 5000:5000 --restart always diamol/registry
Unable to find image 'diamol/registry:latest' locally
latest: Pulling from diamol/registry
31603596830f: Pull complete 
792f5419a843: Pull complete 
3fec9ac2e0fe: Pull complete 
aea0fab1b866: Pull complete 
b72408f4bc4f: Pull complete 
6a2aeb3b52c0: Pull complete 
Digest: sha256:49c5a928c870d496013d98d4357c93f35b1896a0385ef275664bc43e69b14950
Status: Downloaded newer image for diamol/registry:latest
156ecf99c999ebba15e2ff2048d749f376a6efb4ac9f32693b0af2c7ac47b47f
```

이 명령으로 실행되는 레지스트리 서버의 기본 포트는 5000이다. 이 레지스트리 도메인 `localhost:5000`을 사용해 이미지에 태그를 부여하면 새로운 레지스트리에 이미지를 푸시할 수 있다. 그러나 이 레지스트리는 로컬 컴퓨터에서만 접근할 수 있기 때문에 크게 유용하진 않다. 그러나 로컬 컴퓨터에 제대로 된 도메인 네임을 붙인다면 더 활용도가 높아질 것이다.

다음 명령은 이렇게 도메인 네임을 별명으로 붙이는 명령이다. 로컬 컴퓨터에 `registry.local`이라는 별명을 추가한다. 별명을 추가하려면, 도메인과 IP 주소의 연결을 기록한 작은 텍스트 파일인 hosts 파일에 새로운 도메인-주소 쌍을 추가하면 된다.

```docker
13.124.105.1    registry.ec2
```

지금부터 이미지 참조에 도메인 네임 `registry.ec2:5000` 를 사용할 수 있다. 이미지에 도메인 네임을 추가하는 방법은 조금 전 도커 허브에 푸시를 위해 태그를 부여했던 방법과 동일하다. 도메인 네임을 지금 붙인 로컬 컴퓨터의 별명으로 치환하면 된다.

```docker
docker image tag image-gallery registry.ec2:5000/gallery/ui:v1
```

로컬 컴퓨터에 실행 중인 레지스트리에는 별도의 인증 수단이 없으며, 레지스트리 운영을 위해 직접 사용할 수 있을 만한 수준은 아니다. 하지만 소규모 팀에서는 상당히 유효하고, 자신만의 이미지 참조 명명 체계를 만들 수 있다는 장점도 있다.

로컬 컴퓨터의 레지스트리에 이미지를 푸시하려면 아직 한 가지 해야할 일이 더 남아 있다. 이 레지스트리 컨테이너는 이미지를 푸시하고 내려받기 위해 보안 프로토콜인 HTTPS 대신 비보안 프로토콜인 HTTP를 사용한다. 도커의 기본 설정에서는 비보안 프로토콜이 적용된 레지스트리를 사용할 수 없게 돼 있다. 비보안 레지스트리를 사용하려면 로컬 컴퓨터의 레지스트리를 비보안 레지스트리 허용 목록에 추가해야 한다.

이미지 레이어의 저장 경로, 도커 API 가 주시하는 포트 번호, 허용된 비보안 레지스트리 목록 등 도커 엔진의 모든 설정은 daemon.json이라는 이름의 JSON 포맷으로 된 설정 파일에 들어 있다. 리눅스에서는 /etc/docker 에 위치한다. (Mac은 /System/Volumes/Data/Users/hee/.docker)

```docker
{
        "builder": { "gc": { "defaultKeepStorage": "20GB", "enabled": true } },
        "experimental": false,
        "features": { "buildkit": true },
        "insecure-registries": ["registry.ec2:5000"]     # 이 부분 추가
}                
```

설정을 수정하고 나면 도커 엔진을 재시작해야 한다. daemon.json 파일을 텍스트 에디터에서 불러들인 다음 위와 같이 JSON 포맷으로 비보안 레지스트리 허용 목록을 추가한다.

```docker
sh-3.2# docker info
Client:
 Context:    default
 Debug Mode: false
 ...
 Insecure Registries:     # 비보안 레지스트리 허용 리스트
  hubproxy.docker.internal:5000
  registry.ec2:5000
  127.0.0.0/8
 Live Restore Enabled: false

sh-3.2# 
```

`docker info` 명령을 사용하면 도커 엔진 설정 정보를 확인할 수 있다.

```docker
sh-3.2# docker image push registry.ec2:5000/gallery/ui:v1
The push refers to repository [registry.ec2:5000/gallery/ui]
d0eed5dc79a8: Pushed 
04694c706e5c: Pushed 
731f7cfe1d00: Pushed 
bf9b21d93d5a: Pushed 
c087aa3a9887: Pushed 
20312b574584: Pushed 
v1: digest: sha256:bf847eebe28f80e9917fc09394d766af452eea90beb608fe91cb80555cbf807e size: 1573
```

서버에서 확인하면 아래와 같이 레포지토리가 만들어진걸 볼 수 있다.

```docker
root@ip-172-31-0-13:/home/ubuntu# curl http://localhost:5000/v2/_catalog
{"repositories":["gallery/ui"]}
```

# 5.5 공식 이미지에서 골든 이미지로 전환하기

공식 이미지는 이와는 개념이 조금 다르다. 공식 이미지로 배포되는 소프트웨어는 주로 오픈소스 소프트웨어로, 해당 프로젝트 개발 팀과 도커가 함께 이미지를 관리한다. 공식 이미지 역시 취약점 탐색을 거치고 주기적으로 업데이트 되며, 잘 최적화된 Dockerfile 스크립트로 구성된다. 공식 이미지의 모든 콘텐츠는 오픈 소스이며 깃허브 저장소에서 Dockerfile 스크립트를 직접 볼 수 있다. 대부분의 경우 이 공식 이미지를 기반 이미지로 삼아 이미지를 빌드하기 시작하지만, 직접 빌드한 이미지를 사용하다 보면 좀 더 많은 것을 통제하고자 하는 시기가 온다. 바로 이 시점에 자신이 선호하는 기반 이미지로 전환한다. 이 이미지를 골든 이미지(golden image)라고 한다.

골든 이미지는 공식 이미지를 기반 이미지로 삼아 인증서나 환경 설정값 등 자신이 필요한 설정을 추가한 것이다. 골든 이미지는 도커 허브의 기업 리포지터리나 자체 리포지터리에서 관리된다. 그리고 해당 기업의 모든 애플리케이션 이미지는 바로 이 골든 이미지를 기반 이미지로 한다.

## 도커 골든 이미지 (Docker Golden Image)란?

**한 문장 정의부터 갈게.**

> **도커 골든 이미지는조직이나 팀에서 “이걸 기준으로 써라”라고 합의된,보안·설정·런타임이 검증된 표준 컨테이너 이미지**야.
> 

즉,

- 아무나 `FROM ubuntu` 해서 막 만드는 이미지 ❌
- **팀/회사 차원에서 표준으로 정한 기준 이미지** ⭕

---

### 왜 “골든(Golden)”이냐?

VM 세계에서 먼저 쓰던 개념이야.

- **Golden VM Image**
    
    → OS 패치, 보안 설정, 계정, 에이전트 다 깔아둔 “기준 이미지”
    

이걸 컨테이너 세계로 가져온 게 **도커 골든 이미지**야.

---

### 도커 골든 이미지의 핵심 특징

### 1️⃣ 신뢰 가능한 베이스

```docker
FROM registry.ec2:5000/base/python:3.11

```

- OS 버전 고정
- 런타임 버전 고정
- 검증된 베이스만 사용

---

### 2️⃣ 보안/운영 설정이 이미 들어있음

예를 들면:

- non-root 유저
- 타임존 설정
- CA 인증서
- 필수 패키지
- 취약점 패치 완료 상태

```docker
RUN adduser -D appuser
USER appuser

```

---

### 3️⃣ 팀 공통 규칙을 강제함

> “우리는 이 이미지만 써”
> 
- ENTRYPOINT 규칙
- 로그 포맷
- 헬스체크
- 기본 포트

```docker
HEALTHCHECK CMD curl -f http://localhost:8080/health || exit 1

```

---

### 4️⃣ 내부 레지스트리에만 존재

대부분 이런 형태야:

```
registry.ec2:5000/base/node:20
registry.ec2:5000/base/java:17
registry.ec2:5000/base/nginx:1.25

```

👉 외부 Docker Hub 직접 사용 ❌

👉 **골든 이미지 → 앱 이미지** 구조

---

## 구조로 보면 이렇게 생김

```
[ Docker Hub ]
     ↓
[ Base OS Image ]
     ↓
[ 🔒 Golden Image ]
     ↓
[ App Image ]

```

앱 개발자는:

```docker
FROM registry.ec2:5000/base/node:20

```

만 쓰면 됨.

---

## 왜 굳이 골든 이미지를 쓰냐?

### ❌ 골든 이미지 없을 때

- 사람마다 `FROM ubuntu:latest`
- 누군 20.04, 누군 22.04
- 패치 여부 제각각
- 장애 나면 “내 컨테이너는 잘 되는데요?”

### ✅ 골든 이미지 있을 때

- 환경 100% 동일
- 보안 감사 대응 쉬움
- 장애 재현 쉬움
- 업데이트도 중앙에서 관리

---

## 도커 골든 이미지 vs 일반 베이스 이미지

| 항목 | 일반 이미지 | 골든 이미지 |
| --- | --- | --- |
| 출처 | Docker Hub | 내부 레지스트리 |
| 버전 관리 | 느슨함 | 엄격 |
| 보안 | 각자 책임 | 중앙 관리 |
| 운영 편의성 | 낮음 | 높음 |
| 실무 사용 | ❌ | ✅ |

---

## 네가 만든 레지스트리랑 딱 연결되는 지점

지금 네가 만든:

```
registry.ec2:5000

```

이거 **골든 이미지 운영용 레지스트리**로 딱이야.

예를 들면:

```
registry.ec2:5000/golden/python:3.11
registry.ec2:5000/golden/nginx:1.25
registry.ec2:5000/golden/node:20

```