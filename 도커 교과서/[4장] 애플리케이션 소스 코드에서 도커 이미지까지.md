**빌드 중에 실행한 명령과 이로 인해 일어난 파일 시스템 변경은 이미지 레이어에 그대로 저장된다.** 이 덕분에 Dockerfile 스크립트는 매우 유연한 패키징 도구가 됐다. 압축 파일을 압축 해제하거나 윈도 인스톨러를 실행하는 등 다양한 일을 패키징 과정에 포함시킬 수 있다.

# 4.1 Dockerfile이 있는데 빌드 서버가 필요할까?

```docker
# 멀티 스테이지 빌드를 적용한 Dockerfile 스크립트
FROM diamol/base AS build-stage
RUN echo 'Buildiing...' > /build.txt

FROM diamol/base AS test-stage
COPY --from=build-stage /build.txt /build.txt
RUN echo 'Testing...' >> /build.txt

FROM diamol/base
COPY --from=test-stage /build.txt /build.txt
CMD cat /build.txt
```

이 스크립트는 빌드가 여러 단계로 나뉘는 멀티 스테이지 빌드를 적용한 것이다. 각 빌드 단계는 `FROM` 인스트럭션으로 시작된다. 필요한 경우 빌드 단계에서 `AS` 파라미터를 이용해 이름을 붙일 수도 있다. 두 단계는 `build-stage`, `test-stage`로 이름이 붙어 있고, 마지막 한 단계는 이름이 없다. **빌드가 여러 단계로 나뉘어 있다고는 하지만, 최종 산출물은 마지막 단계의 내용물을 담은 도커 이미지다.**

각 빌드 단계는 독립적으로 실행되지만, 앞선 단계에서 만들어진 디렉터리나 파일을 복사할 수는 있다. `COPY` 인스트럭션을 보면 `--from` 인자를 사용해 해당 파일이 호스트 컴퓨터의 파일 시스템이 아니라 앞선 빌드 단계의 파일 시스템에 있는 파일임을 알려준다. 이 예제에서는 `build-stage` 단계에서 파일 하나를 생성하는데, 이 파일을 `test-stage`로 복사하고 다시 `test-stage`에서 생성한 파일을 마지막 단계로 복사한다.

`RUN` 인스트럭션은 파일을 생성하기 위해 사용했다. 빌드 중에 컨테이너 안에서 명령을 실행한 다음 그 결과를 이미지 레이어에 저장하는 기능을 한다. `RUN` 인스트럭션에서 실행할 수 있는 명령에는 특별한 제한이 없지만, `FROM` 인스트럭션에 지정한 이미지에서 실행할 수 있는 것이어야 한다.

각 빌드 단계는 서로 격리돼 있다는 것을 이해해야 한다. 빌드 단계별로 기반 이미지도 다를 수 있으므로 사용할 수 있는 도구도 달라진다. 마지막 빌드 단계의 산출물은 이전 빌드 단계에서 명시적으로 복사해 온 것만 포함할 수 있다. 어느 한 단계에서라도 명령이 실패하면 전체 빌드가 실패한다.

```docker
hee@yuhuijin-ui-MacBookAir multi-stage % docker image build -t multi-stage .
[+] Building 2.5s (9/9) FINISHED                                                                                
 => [internal] load build definition from Dockerfile                                                       0.0s
 => => transferring dockerfile: 307B                                                                       0.0s
 => [internal] load .dockerignore                                                                          0.0s
 => => transferring context: 2B                                                                            0.0s
 => [internal] load metadata for docker.io/diamol/base:latest                                              1.7s
 => CACHED [build-stage 1/2] FROM docker.io/diamol/base@sha256:787fe221a14f46b55e224ea0436aca77d345c3ded4  0.0s
 **=> [build-stage 2/2] RUN echo 'Building...' > /build.txt                                                  0.3s
 => [test-stage 2/3] COPY --from=build-stage /build.txt /build.txt                                         0.0s
 => [test-stage 3/3] RUN echo 'Testing...' >> /build.txt                                                   0.2s
 => [stage-2 2/2] COPY --from=test-stage /build.txt /build.txt**                                             0.0s
 => exporting to image                                                                                     0.0s
 => => exporting layers                                                                                    0.0s
 => => writing image sha256:386e824277391f336928069cdbcfee08a8065303a59b37d30ae8fc03edd6e4c4               0.0s
 => => naming to docker.io/library/multi-stage                                                             0.0s
hee@yuhuijin-ui-MacBookAir multi-stage % 
```

빌드 명령을 입력하면 Dockerfile 스크립트에 작성된 순서를 따라 빌드가 진행되는 것을 볼 수 있다.

`build-stage` 단계에서는 빌드 도구가 설치된 기반 이미지를 사용한다. 로컬 컴퓨터에서 소스 코드를 복사해 넣고, build 명령을 실행한다. 그리고 단위 테스트 프레임워크가 설치된 기반 이미지를 사용하며 앞서 빌드한 바이너리를 복사해 간 다음 단위 테스트를 수행하는 `test-stage` 단계를 추가할 수도 있다. 마지막 단계는 애플리케이션을 실행할 런타임이 들어 있는 기반 이미지로 시작한다. 그리고 `build-stage` 에서 빌드하고 `test-stage`에서 테스트까지 성공적으로 마친 바이너리를 이 이미지에 복사해 넣는다.

# 4.2 애플리케이션 빌드 실전 예제: 자바 소스 코드

builder 단계가 끝나고 나면, 컴파일된 애플리케이션이 패당 단계의 파일 시스템에 만들어진다. 메이븐을 이용한 빌드 과정에 문제가 있었다면 `RUN` 인스트럭션이 실패하면서 전체 빌드도 실패한다.

builder 단계를 정상적으로 마쳤다면, 다음 과정을 수행하는 마지막 단계를 실행해 애플리케이션 이미지를 생성한다.

```docker
hee@yuhuijin-ui-MacBookAir image-of-the-day % docker image build -t image-of-the-day .
[+] Building 83.7s (15/15) FINISHED                                                                             
 => [internal] load build definition from Dockerfile                                                       0.0s
 => => transferring dockerfile: 346B                                                                       0.0s
 => [internal] load .dockerignore                                                                          0.0s
 => => transferring context: 2B                                                                            0.0s
 => [internal] load metadata for docker.io/diamol/openjdk:latest                                           2.7s
 => [internal] load metadata for docker.io/diamol/maven:latest                                             3.0s
 => [builder 1/6] FROM docker.io/diamol/maven@sha256:bc24b7b3beaae18550590fd986b09d7833c4daedb2632c76dad  37.6s
 => => resolve docker.io/diamol/maven@sha256:bc24b7b3beaae18550590fd986b09d7833c4daedb2632c76daddab21351b  0.0s
 => => sha256:4c0955102f3f5a174781c0781a7ab326abd75b82fb5b73821afa349206630e7e 8.92kB / 8.92kB             0.0s
 => => sha256:06af62193c25241eb123af8cf115c7a6298e834976fe148ac79ec11a7ca06ee5 7.69MB / 7.69MB             2.1s
 => => sha256:bc24b7b3beaae18550590fd986b09d7833c4daedb2632c76daddab21351b934f 1.41kB / 1.41kB             0.0s
 => => sha256:088997457a8974eaac75aeb011b9589606b22fba0c660ef63ee71ec3f4e6feee 2.42kB / 2.42kB             0.0s
 => => sha256:c78c297fb0d010ee085f95ae439636ecb167b050c1acb4273bd576998cf94a83 49.18MB / 49.18MB           9.1s
 => => sha256:8b846e1b73901174c506ae5e6219ac2f356ef71eaa5896dfbc238dc67ca4bf73 9.98MB / 9.98MB             2.8s
 => => sha256:fb44d26a138a8d064a4ab8f9b472c64e7136c2482ec5af19bab8811b6d2c15b7 52.17MB / 52.17MB          11.6s
 => => sha256:0328821646cca37a6d16b29f865b06f587912b17e84f293bc7c08bbb3afeee93 5.28MB / 5.28MB             5.5s
 => => sha256:39642fd375ee8d38fc5c53324d4a02c9cf405fcac34ce88cc4d5913274246cb6 210B / 210B                 5.9s
 => => sha256:582c31bf5e2daffdf5c6e05aecaefab313a0b8e776f9ff1575ad3a05973085f4 200.40MB / 200.40MB        32.6s
 => => sha256:529d17dd69ab43de9e243244bf7156c70339386a8571afdf313d05fec3e75dc9 9.58MB / 9.58MB            11.9s
 => => extracting sha256:c78c297fb0d010ee085f95ae439636ecb167b050c1acb4273bd576998cf94a83                  2.5s
 => => sha256:6b8169d349247080880be851b72f835bb8d922ed11366ec88ade11f879a2c6d7 853B / 853B                12.6s
 => => sha256:7997087f808e3e962fa04c72a22f693930bff7640f2ef74a6be97fd09eb14797 360B / 360B                12.6s
 => => extracting sha256:06af62193c25241eb123af8cf115c7a6298e834976fe148ac79ec11a7ca06ee5                  0.4s
 => => extracting sha256:8b846e1b73901174c506ae5e6219ac2f356ef71eaa5896dfbc238dc67ca4bf73                  0.3s
 => => extracting sha256:fb44d26a138a8d064a4ab8f9b472c64e7136c2482ec5af19bab8811b6d2c15b7                  2.7s
 => => extracting sha256:0328821646cca37a6d16b29f865b06f587912b17e84f293bc7c08bbb3afeee93                  0.3s
 => => extracting sha256:39642fd375ee8d38fc5c53324d4a02c9cf405fcac34ce88cc4d5913274246cb6                  0.0s
 => => extracting sha256:582c31bf5e2daffdf5c6e05aecaefab313a0b8e776f9ff1575ad3a05973085f4                  4.5s
 => => extracting sha256:529d17dd69ab43de9e243244bf7156c70339386a8571afdf313d05fec3e75dc9                  0.2s
 => => extracting sha256:6b8169d349247080880be851b72f835bb8d922ed11366ec88ade11f879a2c6d7                  0.0s
 => => extracting sha256:7997087f808e3e962fa04c72a22f693930bff7640f2ef74a6be97fd09eb14797                  0.0s
 => [stage-1 1/3] FROM docker.io/diamol/openjdk@sha256:bc11278602c48a60f71ea01031c54a73878d19db4803f7dd8  27.6s
 => => resolve docker.io/diamol/openjdk@sha256:bc11278602c48a60f71ea01031c54a73878d19db4803f7dd8705aa77ba  0.0s
 => => sha256:bc11278602c48a60f71ea01031c54a73878d19db4803f7dd8705aa77bab89808 1.41kB / 1.41kB             0.0s
 => => sha256:0af0464095ea140f43a30b4cdee3b339a22635efcd930c680f17daee14afa7da 1.37kB / 1.37kB             0.0s
 => => sha256:17e883a5a4c7fa8e70d958b062d11575df249107a3053563f1e4de61a77c0039 5.67kB / 5.67kB             0.0s
 => => sha256:706ee5d0a6b53d9257cbea22d8409fb22c867ab3a001c65f6b8bfd37dace0e58 25.86MB / 25.86MB          17.9s
 => => sha256:303a8d33f3a602102b6a15a1f7974fc79449cdcff2c2fa6709b56cd1ac792384 3.12MB / 3.12MB            14.0s
 => => sha256:93b8b66a2613c2e81c20d5f33497aaa0c185225f7b1a0fc1478b628ad5bce829 211B / 211B                14.5s
 => => sha256:4b08a8fe7570eea8d3f52461e1667f5809826377f1ee2f99e5cc9690946de148 46.11MB / 46.11MB          23.9s
 => => sha256:5536d457e12456a73a534d7de853981653618af70af4b4d0bea264f332236f5e 1.99MB / 1.99MB            18.6s
 => => extracting sha256:706ee5d0a6b53d9257cbea22d8409fb22c867ab3a001c65f6b8bfd37dace0e58                  1.7s
 => => extracting sha256:303a8d33f3a602102b6a15a1f7974fc79449cdcff2c2fa6709b56cd1ac792384                  0.3s
 => => extracting sha256:93b8b66a2613c2e81c20d5f33497aaa0c185225f7b1a0fc1478b628ad5bce829                  0.0s
 => => extracting sha256:4b08a8fe7570eea8d3f52461e1667f5809826377f1ee2f99e5cc9690946de148                  2.7s
 => => extracting sha256:5536d457e12456a73a534d7de853981653618af70af4b4d0bea264f332236f5e                  0.2s
 => [internal] load build context                                                                          0.0s
 => => transferring context: 9.76kB                                                                        0.0s
 => [stage-1 2/3] WORKDIR /app                                                                             0.1s
 => [builder 2/6] WORKDIR /usr/src/iotd                                                                    0.6s
 => [builder 3/6] COPY pom.xml .                                                                           0.0s
 => [builder 4/6] RUN mvn -B dependency:go-offline                                                        39.1s
 => [builder 5/6] COPY . .                                                                                 0.0s
 => [builder 6/6] RUN mvn package                                                                          3.1s
 => [stage-1 3/3] COPY --from=builder /usr/src/iotd/target/iotd-service-0.1.0.jar .                        0.1s
 => exporting to image                                                                                     0.1s
 => => exporting layers                                                                                    0.1s
 => => writing image sha256:6273b17cc185322f10b60b510448922d09a94101d976c16922ab72c24f6910f4               0.0s
 => => naming to docker.io/library/image-of-the-day                                                        0.0s
```

이 이미지를 빌드하면 메이븐이 출력하는 상당한 양의 로그를 볼 수 있다. 그 내용은 의존 모듈을 내려받고 자바 빌드를 실행하는 내용이다.

컨테이너는 컨테이너가 실행될 때 부여되는 가상 네트워크 내 가상 IP를 통해 서로 통신한다. 이 가상 네트워크 역시 명령행 인터페이스를 통해 관리할 수 있다.

```docker
hee@yuhuijin-ui-MacBookAir image-of-the-day % docker network create nat
352dc4fd0daf13a2519305d696b6d3197cf5c129eaaaa190dbc07c9cd9c75f6d
```

이 명령을 실행했을 때 오류 메시지가 출력된다면, nat이라는 이름의 도커 네트워크를 이미 생성했기 때문이다. 이 오류 메시지는 무시해도 좋다. 그리고 컨테이너를 실행할 때 `--network` 옵션을 사용하면 새로 만들 컨테이너를 연결할 네트워크를 직접 지정할 수 있다. 같은 네트워크 안에 속한 컨테이너 간에는 서로 자유롭게 통신이 가능하다.

```docker
hee@yuhuijin-ui-MacBookAir image-of-the-day % docker container run --name iotd -d -p 800:80 --network nat image-
of-the-day
8b5c8c0453b2685752fe4b49e0c554320b2e6d307254607988bdf7641a4df560
```

이제 웹 브라우저에서 http://localhost:800/image에 접근해보면 NASA에서 제공하는 오늘의 사진에 대한 정보를 JSON 포맷으로 볼 수 있다.

진짜 중요한 것은 도커만 설치돼 있다면 이 애플리케이션을 어디서든 실행할 수 있다는 점이다. 소스 코드와 Dockerfile 스크립트만 있으면 된다. 그 외에는 빌드 도구를 설치할 필요도 없고 특정한 버전의 자바 런타임을 설치할 필요도 없다. 코드 저장소를 복제한 다음 도커 명령 두어 개만 실행하면 애플리케이션을 실행할 수 있다.

최종적으로 생성되는 애플리케이션 이미지에 빌드 도구는 포함되지 않는다. `image-of-the-day` 이미지를 사용해 대화식 컨테이너를 실행해보면, 이 이미지에서는 `mvn` 명령을 사용할 수 없다는 것을 알 수 있다. 애플리케이션 이미지에는 도커 파일에 정의된 빌드 단계중 마지막 단계의 콘텐츠만이 포함된다. 이전 단계의 콘텐츠 중 포함시키고 싶은 것이 있다면 최종 단계에서 명시적으로 해당 콘텐츠를 복사해 와야 한다.

# 4.3 애플리케이션 빌드 실전 예제: Node.js 소스 코드

Node.js 애플리케이션은 자바스크립트로 구현된다. 자바스크립트는 인터프리터형 언어로 별도의 컴파일 절차가 필요없다. 컨테이너화된 Node.js 애플리케이션을 실행하려면 Node.js 런타임과 소스 코드가 애플리케이션 이미지에 포함돼야 한다.

그렇다고 멀티 스테이지 빌드가 필요하지 않은 것은 아니다. 멀티 스테이지 빌드를 통해 의존 모듈 로딩을 최적화할 수 있다. Node.js는 npm이라는 패키지 관리자를 사용해 의존 모듈을 관리한다.

```docker
FROM diamol/node AS builder

WORKDIr /src
COPY src/package.json .

RUN npm install

FROM diamol/node

EXPOSE 80

CMD ["node", "server.js"]

WORKDIR /app
COPY --from=builder /src/node_modules ./node_modules
COPY src/ .
```

이 스크립트의 목표 역시 앞서와 마찬가지로, 애플리케이션을 패키징하고 다른 도구 없이 도커만 설치된 환경에서 애플리케이션을 실행하는 것이다. 두 이미지 모두 diamol/node를 기반 이미지로 사용한다. 이 이미지는 Node.js 런타임과 npm이 설치된 이미지다. builder 단계에서 애플리케이션의 의존 모듈이 정의된 package.json 파일을 복사한 다음, `npm install` 명령을 실행해 의존 모듈을 내려받는다. 별도의 컴파일이 필요치 않으므로 빌드 과정은 이것이 전부다.

이 Node.js 애플리케이션 역시 REST API다. 최종 단계에서 공개할 HTTP 포트와 애플리케이션 시작 명령을 지정한다. 최종 단계는 작업 디렉터리를 만들고 호스트 컴퓨터로부터 애플리케이션 아티팩트를 모두 복사해 넣는 것으로 끝난다. src 디렉터리는 애플리케이션의 진입점 역할을 하는 server.js 파일을 비롯해 여러 자바스크립트 파일을 담고 있다.

```docker
hee@yuhuijin-ui-MacBookAir access-log % docker image build -t access-log .
[+] Building 7.5s (12/12) FINISHED                                                                              
 => [internal] load build definition from Dockerfile                                                       0.0s
 => => transferring dockerfile: 270B                                                                       0.0s
 => [internal] load .dockerignore                                                                          0.0s
 => => transferring context: 2B                                                                            0.0s
 => [internal] load metadata for docker.io/diamol/node:latest                                              1.7s
 => [internal] load build context                                                                          0.0s
 => => transferring context: 1.57kB                                                                        0.0s
 => CACHED [builder 1/4] FROM docker.io/diamol/node@sha256:dfee522acebdfdd9964aa9c88ebebd03a20b6dd5739083  0.0s
 => [builder 2/4] WORKDIR /src                                                                             0.0s
 => [stage-1 2/4] WORKDIR /app                                                                             0.0s
 => [builder 3/4] COPY src/package.json .                                                                  0.0s
 => [builder 4/4] RUN npm install                                                                          4.7s
 => [stage-1 3/4] COPY --from=builder /src/node_modules/ /app/node_modules/                                0.5s 
 => [stage-1 4/4] COPY src/ .                                                                              0.0s 
 => exporting to image                                                                                     0.3s 
 => => exporting layers                                                                                    0.3s 
 => => writing image sha256:275b111e563d4eaaede586484d35edc971be259d0d239c2ec5bb0aa9f3717961               0.0s
 => => naming to docker.io/library/access-log  
```

내려받은 의존 모듈은 도커 이미지 레이어 캐시에 저장되므로 의존 모듈 추가 없이 코드만 수정했다면 그 다음 번 빌드는 지금보다 매우 빠르게 진행된다.

```docker
hee@yuhuijin-ui-MacBookAir access-log % docker container run --name accesslog -d -p 801:80 --network nat access-
log
15e9b25e0a182a37f064dd86cd00068da36f4282bd8957892c17612c355a2184
```

# 4.4 애플리케이션 빌드 실전 예제: Go 소스 코드

```docker
FROM diamol/golang AS builder

COPY main.go .
RUN go build -o /server

# app
FROM diamol/base

ENV IMAGE_API_URL="http://iotd/image" \
    ACCESS_API_URL="http://accesslog/access-log"

CMD ["/web/server"]

WORKDIR /web
COPY index.html .
COPY --from=builder /server .
RUN chmod +x server
```

Go는 네이티브 바이너리로 컴파일된다. 그러므로 이 Dockerfile 스크립트의 각 빌드 단계는 서로 다른 기반 이미지를 사용한다. builder 단계의 기반 이미지는 Go 언어의 도구가 설치된 `diamol/golang` 이다. Go 애플리케이션 빌드는 일반적으로 의존 모듈을 내려받는 단계 없이 곧장 빌드에 들어가며, 그 다음 애플리케이션 단계는 최소한의 운영체제 레이어만을 포함하는 이미지를 사용한다.

그 다음에는 몇 가지 설정값을 환경 변수 형태로 설정하고 컴파일된 바이너리를 실행해 애플리케이션을 시작한다. 애플리케이션 단계는 builder 단계에서 빌드한 웹 서버 바이너리와 이 웹 서버가 제공할 HTML 파일을 복사하는 과정으로 마무리 된다. 마지막으로, 바이너리 파일이 `chmod` 명령을 통해 명시적으로 실행 권한을 부여받는다.

```docker
hee@yuhuijin-ui-MacBookAir image-gallery % docker image build -t image-gallery .
[+] Building 39.1s (14/14) FINISHED                                                                             
 => [internal] load build definition from Dockerfile                                                       0.0s
 => => transferring dockerfile: 344B                                                                       0.0s
 => [internal] load .dockerignore                                                                          0.0s
 => => transferring context: 2B                                                                            0.0s
 => [internal] load metadata for docker.io/diamol/base:latest                                              1.8s
 => [internal] load metadata for docker.io/diamol/golang:latest                                            3.3s
 => CACHED [stage-1 1/5] FROM docker.io/diamol/base@sha256:787fe221a14f46b55e224ea0436aca77d345c3ded400aa  0.0s
 => [internal] load build context                                                                          0.0s
 => => transferring context: 1.67kB                                                                        0.0s
 => [builder 1/3] FROM docker.io/diamol/golang@sha256:ffc019466b60046d67b71628afafc9f80cc4d6a6bce824dc89  31.2s
 => => resolve docker.io/diamol/golang@sha256:ffc019466b60046d67b71628afafc9f80cc4d6a6bce824dc89d51300ece  0.0s
 => => sha256:ffc019466b60046d67b71628afafc9f80cc4d6a6bce824dc89d51300ecec0902 1.41kB / 1.41kB             0.0s
 => => sha256:0283897ad4463628bd259e1cbb5eb788e7df554b42ae17fc6f5d02c4a56035c2 7.68MB / 7.68MB             2.8s
 => => sha256:3feb40d9f5fecfa098b8f7ece6c287c6fd61b114043c8b4647359120a7d943a3 9.98MB / 9.98MB             2.8s
 => => sha256:1910bbf0b9a0f73613c202e13d9940c1050acf3f4522a553c60637992f5dd7a2 1.79kB / 1.79kB             0.0s
 => => sha256:928e2ab79c640602110b5ef0ca5969e6856fc874ee8537c6ede1c60dd18bf1ea 6.35kB / 6.35kB             0.0s
 => => sha256:d5517ee72007172d5b814636405254dea459120ce08f85777bb287d106a6a240 49.18MB / 49.18MB          13.0s
 => => sha256:f86b5fabb62f79acd92186da3c02d23bd8c15d79603a700959b582bd9e62854c 52.16MB / 52.16MB          16.7s
 => => sha256:37c836803dd1977ffe173b42414e8c2ae2e147cee2e1ee34a383f4251cf15a44 62.53MB / 62.53MB          19.5s
 => => extracting sha256:d5517ee72007172d5b814636405254dea459120ce08f85777bb287d106a6a240                  2.2s
 => => sha256:d9dc248055f60dc2aa62c9eb18d6b6f4ec0de19f410168704b3a59da5801d8fe 97.69MB / 97.69MB          27.5s
 => => extracting sha256:0283897ad4463628bd259e1cbb5eb788e7df554b42ae17fc6f5d02c4a56035c2                  0.3s
 => => extracting sha256:3feb40d9f5fecfa098b8f7ece6c287c6fd61b114043c8b4647359120a7d943a3                  0.3s
 => => sha256:f7bc7fcd16054fc4f78b4420338b2694561bcb99063f896a8d4cf6e61a2596f5 156B / 156B                17.3s
 => => extracting sha256:f86b5fabb62f79acd92186da3c02d23bd8c15d79603a700959b582bd9e62854c                  2.5s
 => => extracting sha256:37c836803dd1977ffe173b42414e8c2ae2e147cee2e1ee34a383f4251cf15a44                  4.0s
 => => extracting sha256:d9dc248055f60dc2aa62c9eb18d6b6f4ec0de19f410168704b3a59da5801d8fe                  3.3s
 => => extracting sha256:f7bc7fcd16054fc4f78b4420338b2694561bcb99063f896a8d4cf6e61a2596f5                  0.0s
 => [stage-1 2/5] WORKDIR /web                                                                             0.0s
 => [stage-1 3/5] COPY index.html .                                                                        0.0s
 => [builder 2/3] COPY main.go .                                                                           0.9s
 => [builder 3/3] RUN go build -o /server                                                                  2.5s
 => [stage-1 4/5] COPY --from=builder /server .                                                            0.1s
 => [stage-1 5/5] RUN chmod +x server                                                                      0.2s
 => exporting to image                                                                                     0.0s
 => => exporting layers                                                                                    0.0s
 => => writing image sha256:7837c9e1c501c5aec370ad770c815a9db0ff211e46be5fa9018110f6304dfe97               0.0s
 => => naming to docker.io/library/image-gallery 
```

```docker
hee@yuhuijin-ui-MacBookAir docker-playground % docker image ls -f reference=diamol/golang -f reference=image-gallery
REPOSITORY      TAG       IMAGE ID       CREATED              SIZE
image-gallery   latest    7837c9e1c501   About a minute ago   26.2MB
```

리눅스 환경을 기준으로, Go 빌드 도구를 포함하는 이미지의 크기는 800MB를 넘어선다. 하지만 실제 Go 애플리케이션 이미지의 크기는 25MB에 불과하다. 다시 강조하지만, 이 크기는 논리적 크기이므로 이미지 간에 많은 수의 레이어가 공유된다. 중요한 부분은 실제 이미지 크기가 아니라 최종 애플리케이션 이미지에 모든 것이 들어가지 않는다는 점이다. Go 애플리케이션은 실행 시에 별도의 Go 빌드 도구가 필요 없다. 그러므로 애플리케이션 이미지의 크기를 최소한으로 유지하며 거의 750MB에 달하는 용량을 줄일 수 있는 것이다. 이는 공격이 가능한 부분 자체를 줄일 수 있다는 점에서 큰 장점이다.

```docker
hee@yuhuijin-ui-MacBookAir image-gallery % docker container run -d -p 802:80 --network nat image-gallery
f0928d150b44802514f969436296f08e9f92c1d37d31d4abf0a553f543cd57c4
```

# 4.5 멀티 스테이지 Dockerfile 스크립트 이해하기

**첫번째 장점은 표준화다.** 독자 여러분이 어떤 운영체제를 사용하든, 그리고 로컬 컴퓨터에 어떤 도구를 설치했는지와 상관없이 모든 빌드 과정은 도커 컨테이너 내부에서 이뤄진다. 그리고 이들 컨테이너는 모든 도구를 정확한 버전으로 갖추고 있다. **이것을 실무에 적용한다면 신규 개발자의 적응 기간이나 빌드 서버의 관리 부담, 혹은 개발자 간 도구 버전의 차이로 인한 빌드 실패를 크게 줄일 수 있을 것이다.**

**두번째 장점은 성능 향상이다.** 멀티 스테이지 빌드의 각 단계는 자신만의 캐시를 따로 갖는다. 그리고 도커는 빌드 중에 각 인스트럭션에 해당하는 레이어 캐시를 찾는다. 해당되는 캐시를 찾지 못하면 남은 인스트럭션이 모두 실행되지만, 그 범위가 해당 단계 안으로 국한된다. 이어지는 다음 단계는 다시 캐시를 재사용하면서 시작할 수 있다. **처음에 Dockerfile 스크립트를 세심하게 최적화해서 작성한다면 이후로 캐시 재사용을 통해 90% 이상의 빌드 단계에서 시간을 절약할 수 있다.**

마지막으로 언급할 장점은 멀티 스테이지 Dockerfile 스크립트를 통해 빌드 과정을 세밀하게 조정하며 최종 산출물인 **이미지를 가능한 한 작게 유지할 수 있다는 점**이다. 비단 컴파일러에만 국한된 내용은 아니다. 어떤 도구든지 그 도구가 사용되는 단계만으로 도구의 포함 여부를 국한시킬 수 있다. **최종 산출물인 이미지에 불필요한 도구는 빼버릴 수 있는 것이다.** 이 좋은 예가 curl 이다. curl 은 인터넷을 통해 필요한 파일을 내려받을 수 있는 중요한 도구이지만, 파일 다운로드를 빌드 초기 단계에 모아 놓는다면 최종 이미지에는 curl을 포함시키지 않아도 된다. 이런 방법으로 이미지 크기를 줄여서 애플리케이션의 시작 시간을 단축할 수 있으며, 애플리케이션의 의존 모듈 자체를 줄여 취약점을 이용한 외부 공격의 가능성도 최대한 차단할 수 있다.

# 4.6 연습 문제

```docker
FROM diamol/golang 

WORKDIR web
COPY index.html .
COPY main.go .

RUN go build -o /web/server
RUN chmod +x /web/server

CMD ["/web/server"]
ENV USER=sixeyed
EXPOSE 80
```

```docker
FROM diamol/golang AS builder 

COPY main.go .
RUN go build -o /web/server

FROM diamol/base

CMD ["/web/server"]
ENV USER=sixeyed
EXPOSE 80

WORKDIR web
COPY index.html .
COPY --from=builder /web/server .
RUN chmod +x /web/server
```

```docker
hee@yuhuijin-ui-MacBookAir lab % docker images
REPOSITORY   TAG       IMAGE ID       CREATED         SIZE
after-go     latest    19ffd8f7f103   9 seconds ago   25.9MB
before-go    latest    9cca8e2121a6   5 minutes ago   736MB
```