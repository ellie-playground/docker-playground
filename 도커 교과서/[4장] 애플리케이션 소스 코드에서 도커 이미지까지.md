**빌드 중에 실행한 명령과 이로 인해 일어난 파일 시스템 변경은 이미지 레이어에 그대로 저장된다.** 이 덕분에 Dockerfile 스크립트는 매우 유연한 패키징 도구가 됐다. 압축 파일을 압축 해제하거나 윈도 인스톨러를 실행하는 등 다양한 일을 패키징 과정에 포함시킬 수 있다.

# 4.1 Dockerfile이 있는데 빌드 서버가 필요할까?

```docker
# 멀티 스테이지 빌드를 적용한 Dockerfile 스크립트
FROM diamol/base AS build-stage
RUN echo 'Buildiing...' > /build.txt

FROM diamol/base AS test-stage
COPY --from=build-stage /build.txt /build.txt
RUN echo 'Testing...' >> /build.txt

FROM diamol/base
COPY --from=test-stage /build.txt /build.txt
CMD cat /build.txt
```

이 스크립트는 빌드가 여러 단계로 나뉘는 멀티 스테이지 빌드를 적용한 것이다. 각 빌드 단계는 `FROM` 인스트럭션으로 시작된다. 필요한 경우 빌드 단계에서 `AS` 파라미터를 이용해 이름을 붙일 수도 있다. 두 단계는 `build-stage`, `test-stage`로 이름이 붙어 있고, 마지막 한 단계는 이름이 없다. **빌드가 여러 단계로 나뉘어 있다고는 하지만, 최종 산출물은 마지막 단계의 내용물을 담은 도커 이미지다.**

각 빌드 단계는 독립적으로 실행되지만, 앞선 단계에서 만들어진 디렉터리나 파일을 복사할 수는 있다. `COPY` 인스트럭션을 보면 `--from` 인자를 사용해 해당 파일이 호스트 컴퓨터의 파일 시스템이 아니라 앞선 빌드 단계의 파일 시스템에 있는 파일임을 알려준다. 이 예제에서는 `build-stage` 단계에서 파일 하나를 생성하는데, 이 파일을 `test-stage`로 복사하고 다시 `test-stage`에서 생성한 파일을 마지막 단계로 복사한다.

`RUN` 인스트럭션은 파일을 생성하기 위해 사용했다. 빌드 중에 컨테이너 안에서 명령을 실행한 다음 그 결과를 이미지 레이어에 저장하는 기능을 한다. `RUN` 인스트럭션에서 실행할 수 있는 명령에는 특별한 제한이 없지만, `FROM` 인스트럭션에 지정한 이미지에서 실행할 수 있는 것이어야 한다.

각 빌드 단계는 서로 격리돼 있다는 것을 이해해야 한다. 빌드 단계별로 기반 이미지도 다를 수 있으므로 사용할 수 있는 도구도 달라진다. 마지막 빌드 단계의 산출물은 이전 빌드 단계에서 명시적으로 복사해 온 것만 포함할 수 있다. 어느 한 단계에서라도 명령이 실패하면 전체 빌드가 실패한다.

```docker
hee@yuhuijin-ui-MacBookAir multi-stage % docker image build -t multi-stage .
[+] Building 2.5s (9/9) FINISHED                                                                                
 => [internal] load build definition from Dockerfile                                                       0.0s
 => => transferring dockerfile: 307B                                                                       0.0s
 => [internal] load .dockerignore                                                                          0.0s
 => => transferring context: 2B                                                                            0.0s
 => [internal] load metadata for docker.io/diamol/base:latest                                              1.7s
 => CACHED [build-stage 1/2] FROM docker.io/diamol/base@sha256:787fe221a14f46b55e224ea0436aca77d345c3ded4  0.0s
 **=> [build-stage 2/2] RUN echo 'Building...' > /build.txt                                                  0.3s
 => [test-stage 2/3] COPY --from=build-stage /build.txt /build.txt                                         0.0s
 => [test-stage 3/3] RUN echo 'Testing...' >> /build.txt                                                   0.2s
 => [stage-2 2/2] COPY --from=test-stage /build.txt /build.txt**                                             0.0s
 => exporting to image                                                                                     0.0s
 => => exporting layers                                                                                    0.0s
 => => writing image sha256:386e824277391f336928069cdbcfee08a8065303a59b37d30ae8fc03edd6e4c4               0.0s
 => => naming to docker.io/library/multi-stage                                                             0.0s
hee@yuhuijin-ui-MacBookAir multi-stage % 
```

빌드 명령을 입력하면 Dockerfile 스크립트에 작성된 순서를 따라 빌드가 진행되는 것을 볼 수 있다.

`build-stage` 단계에서는 빌드 도구가 설치된 기반 이미지를 사용한다. 로컬 컴퓨터에서 소스 코드를 복사해 넣고, build 명령을 실행한다. 그리고 단위 테스트 프레임워크가 설치된 기반 이미지를 사용하며 앞서 빌드한 바이너리를 복사해 간 다음 단위 테스트를 수행하는 `test-stage` 단계를 추가할 수도 있다. 마지막 단계는 애플리케이션을 실행할 런타임이 들어 있는 기반 이미지로 시작한다. 그리고 `build-stage` 에서 빌드하고 `test-stage`에서 테스트까지 성공적으로 마친 바이너리를 이 이미지에 복사해 넣는다.

# 4.2 애플리케이션 빌드 실전 예제: 자바 소스 코드

builder 단계가 끝나고 나면, 컴파일된 애플리케이션이 패당 단계의 파일 시스템에 만들어진다. 메이븐을 이용한 빌드 과정에 문제가 있었다면 `RUN` 인스트럭션이 실패하면서 전체 빌드도 실패한다.

builder 단계를 정상적으로 마쳤다면, 다음 과정을 수행하는 마지막 단계를 실행해 애플리케이션 이미지를 생성한다.

```docker
hee@yuhuijin-ui-MacBookAir image-of-the-day % docker image build -t image-of-the-day .
[+] Building 83.7s (15/15) FINISHED                                                                             
 => [internal] load build definition from Dockerfile                                                       0.0s
 => => transferring dockerfile: 346B                                                                       0.0s
 => [internal] load .dockerignore                                                                          0.0s
 => => transferring context: 2B                                                                            0.0s
 => [internal] load metadata for docker.io/diamol/openjdk:latest                                           2.7s
 => [internal] load metadata for docker.io/diamol/maven:latest                                             3.0s
 => [builder 1/6] FROM docker.io/diamol/maven@sha256:bc24b7b3beaae18550590fd986b09d7833c4daedb2632c76dad  37.6s
 => => resolve docker.io/diamol/maven@sha256:bc24b7b3beaae18550590fd986b09d7833c4daedb2632c76daddab21351b  0.0s
 => => sha256:4c0955102f3f5a174781c0781a7ab326abd75b82fb5b73821afa349206630e7e 8.92kB / 8.92kB             0.0s
 => => sha256:06af62193c25241eb123af8cf115c7a6298e834976fe148ac79ec11a7ca06ee5 7.69MB / 7.69MB             2.1s
 => => sha256:bc24b7b3beaae18550590fd986b09d7833c4daedb2632c76daddab21351b934f 1.41kB / 1.41kB             0.0s
 => => sha256:088997457a8974eaac75aeb011b9589606b22fba0c660ef63ee71ec3f4e6feee 2.42kB / 2.42kB             0.0s
 => => sha256:c78c297fb0d010ee085f95ae439636ecb167b050c1acb4273bd576998cf94a83 49.18MB / 49.18MB           9.1s
 => => sha256:8b846e1b73901174c506ae5e6219ac2f356ef71eaa5896dfbc238dc67ca4bf73 9.98MB / 9.98MB             2.8s
 => => sha256:fb44d26a138a8d064a4ab8f9b472c64e7136c2482ec5af19bab8811b6d2c15b7 52.17MB / 52.17MB          11.6s
 => => sha256:0328821646cca37a6d16b29f865b06f587912b17e84f293bc7c08bbb3afeee93 5.28MB / 5.28MB             5.5s
 => => sha256:39642fd375ee8d38fc5c53324d4a02c9cf405fcac34ce88cc4d5913274246cb6 210B / 210B                 5.9s
 => => sha256:582c31bf5e2daffdf5c6e05aecaefab313a0b8e776f9ff1575ad3a05973085f4 200.40MB / 200.40MB        32.6s
 => => sha256:529d17dd69ab43de9e243244bf7156c70339386a8571afdf313d05fec3e75dc9 9.58MB / 9.58MB            11.9s
 => => extracting sha256:c78c297fb0d010ee085f95ae439636ecb167b050c1acb4273bd576998cf94a83                  2.5s
 => => sha256:6b8169d349247080880be851b72f835bb8d922ed11366ec88ade11f879a2c6d7 853B / 853B                12.6s
 => => sha256:7997087f808e3e962fa04c72a22f693930bff7640f2ef74a6be97fd09eb14797 360B / 360B                12.6s
 => => extracting sha256:06af62193c25241eb123af8cf115c7a6298e834976fe148ac79ec11a7ca06ee5                  0.4s
 => => extracting sha256:8b846e1b73901174c506ae5e6219ac2f356ef71eaa5896dfbc238dc67ca4bf73                  0.3s
 => => extracting sha256:fb44d26a138a8d064a4ab8f9b472c64e7136c2482ec5af19bab8811b6d2c15b7                  2.7s
 => => extracting sha256:0328821646cca37a6d16b29f865b06f587912b17e84f293bc7c08bbb3afeee93                  0.3s
 => => extracting sha256:39642fd375ee8d38fc5c53324d4a02c9cf405fcac34ce88cc4d5913274246cb6                  0.0s
 => => extracting sha256:582c31bf5e2daffdf5c6e05aecaefab313a0b8e776f9ff1575ad3a05973085f4                  4.5s
 => => extracting sha256:529d17dd69ab43de9e243244bf7156c70339386a8571afdf313d05fec3e75dc9                  0.2s
 => => extracting sha256:6b8169d349247080880be851b72f835bb8d922ed11366ec88ade11f879a2c6d7                  0.0s
 => => extracting sha256:7997087f808e3e962fa04c72a22f693930bff7640f2ef74a6be97fd09eb14797                  0.0s
 => [stage-1 1/3] FROM docker.io/diamol/openjdk@sha256:bc11278602c48a60f71ea01031c54a73878d19db4803f7dd8  27.6s
 => => resolve docker.io/diamol/openjdk@sha256:bc11278602c48a60f71ea01031c54a73878d19db4803f7dd8705aa77ba  0.0s
 => => sha256:bc11278602c48a60f71ea01031c54a73878d19db4803f7dd8705aa77bab89808 1.41kB / 1.41kB             0.0s
 => => sha256:0af0464095ea140f43a30b4cdee3b339a22635efcd930c680f17daee14afa7da 1.37kB / 1.37kB             0.0s
 => => sha256:17e883a5a4c7fa8e70d958b062d11575df249107a3053563f1e4de61a77c0039 5.67kB / 5.67kB             0.0s
 => => sha256:706ee5d0a6b53d9257cbea22d8409fb22c867ab3a001c65f6b8bfd37dace0e58 25.86MB / 25.86MB          17.9s
 => => sha256:303a8d33f3a602102b6a15a1f7974fc79449cdcff2c2fa6709b56cd1ac792384 3.12MB / 3.12MB            14.0s
 => => sha256:93b8b66a2613c2e81c20d5f33497aaa0c185225f7b1a0fc1478b628ad5bce829 211B / 211B                14.5s
 => => sha256:4b08a8fe7570eea8d3f52461e1667f5809826377f1ee2f99e5cc9690946de148 46.11MB / 46.11MB          23.9s
 => => sha256:5536d457e12456a73a534d7de853981653618af70af4b4d0bea264f332236f5e 1.99MB / 1.99MB            18.6s
 => => extracting sha256:706ee5d0a6b53d9257cbea22d8409fb22c867ab3a001c65f6b8bfd37dace0e58                  1.7s
 => => extracting sha256:303a8d33f3a602102b6a15a1f7974fc79449cdcff2c2fa6709b56cd1ac792384                  0.3s
 => => extracting sha256:93b8b66a2613c2e81c20d5f33497aaa0c185225f7b1a0fc1478b628ad5bce829                  0.0s
 => => extracting sha256:4b08a8fe7570eea8d3f52461e1667f5809826377f1ee2f99e5cc9690946de148                  2.7s
 => => extracting sha256:5536d457e12456a73a534d7de853981653618af70af4b4d0bea264f332236f5e                  0.2s
 => [internal] load build context                                                                          0.0s
 => => transferring context: 9.76kB                                                                        0.0s
 => [stage-1 2/3] WORKDIR /app                                                                             0.1s
 => [builder 2/6] WORKDIR /usr/src/iotd                                                                    0.6s
 => [builder 3/6] COPY pom.xml .                                                                           0.0s
 => [builder 4/6] RUN mvn -B dependency:go-offline                                                        39.1s
 => [builder 5/6] COPY . .                                                                                 0.0s
 => [builder 6/6] RUN mvn package                                                                          3.1s
 => [stage-1 3/3] COPY --from=builder /usr/src/iotd/target/iotd-service-0.1.0.jar .                        0.1s
 => exporting to image                                                                                     0.1s
 => => exporting layers                                                                                    0.1s
 => => writing image sha256:6273b17cc185322f10b60b510448922d09a94101d976c16922ab72c24f6910f4               0.0s
 => => naming to docker.io/library/image-of-the-day                                                        0.0s
```

이 이미지를 빌드하면 메이븐이 출력하는 상당한 양의 로그를 볼 수 있다. 그 내용은 의존 모듈을 내려받고 자바 빌드를 실행하는 내용이다.

컨테이너는 컨테이너가 실행될 때 부여되는 가상 네트워크 내 가상 IP를 통해 서로 통신한다. 이 가상 네트워크 역시 명령행 인터페이스를 통해 관리할 수 있다.

```docker
hee@yuhuijin-ui-MacBookAir image-of-the-day % docker network create nat
352dc4fd0daf13a2519305d696b6d3197cf5c129eaaaa190dbc07c9cd9c75f6d
```

이 명령을 실행했을 때 오류 메시지가 출력된다면, nat이라는 이름의 도커 네트워크를 이미 생성했기 때문이다. 이 오류 메시지는 무시해도 좋다. 그리고 컨테이너를 실행할 때 `--network` 옵션을 사용하면 새로 만들 컨테이너를 연결할 네트워크를 직접 지정할 수 있다. 같은 네트워크 안에 속한 컨테이너 간에는 서로 자유롭게 통신이 가능하다.

```docker
hee@yuhuijin-ui-MacBookAir image-of-the-day % docker container run --name iotd -d -p 800:80 --network nat image-
of-the-day
8b5c8c0453b2685752fe4b49e0c554320b2e6d307254607988bdf7641a4df560
```

이제 웹 브라우저에서 http://localhost:800/image에 접근해보면 NASA에서 제공하는 오늘의 사진에 대한 정보를 JSON 포맷으로 볼 수 있다.

진짜 중요한 것은 도커만 설치돼 있다면 이 애플리케이션을 어디서든 실행할 수 있다는 점이다. 소스 코드와 Dockerfile 스크립트만 있으면 된다. 그 외에는 빌드 도구를 설치할 필요도 없고 특정한 버전의 자바 런타임을 설치할 필요도 없다. 코드 저장소를 복제한 다음 도커 명령 두어 개만 실행하면 애플리케이션을 실행할 수 있다.

최종적으로 생성되는 애플리케이션 이미지에 빌드 도구는 포함되지 않는다. `image-of-the-day` 이미지를 사용해 대화식 컨테이너를 실행해보면, 이 이미지에서는 `mvn` 명령을 사용할 수 없다는 것을 알 수 있다. 애플리케이션 이미지에는 도커 파일에 정의된 빌드 단계중 마지막 단계의 콘텐츠만이 포함된다. 이전 단계의 콘텐츠 중 포함시키고 싶은 것이 있다면 최종 단계에서 명시적으로 해당 콘텐츠를 복사해 와야 한다.