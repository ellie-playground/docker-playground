# 3.1 도커 허브에 공유된 이미지 사용하기

2장에서 `docker container run` 명령을 사용할 때 필요한 이미지 중 로컬 컴퓨터에 없는 이미지가 있으면 이미지를 내려받는 과정을 봤을 것이다. 이 과정은 소프트웨어 배포 기능이 도커 플랫폼에 완전히 내장됐기 때문에 가능했다. 이미지를 내려받는 과정을 이처럼 도커에 전적으로 맡길 수도 있지만, 도커 cli를 통해 명시적으로 원하는 이미지를 내려받을 수도 있다.

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker image pull diamol/ch03-web-ping
Using default tag: latest
latest: Pulling from diamol/ch03-web-ping
0362ad1dd800: Pull complete 
b09a182c47e8: Pull complete 
39d61d2ed871: Pull complete 
b4e2115e274a: Pull complete 
f5cca017994f: Pull complete 
f504555623f6: Pull complete 
Digest: sha256:2f2dce710a7f287afc2d7bbd0d68d024bab5ee37a1f658cef46c64b1a69affd2
Status: Downloaded newer image for diamol/ch03-web-ping:latest
docker.io/diamol/ch03-web-ping:latest
```

이미지 이름은 diamol/ch03-web-ping 이고, 이 이미지는 도커가 가장 먼저 이미지를 찾기 위해 접근하는 저장소인 도커 허브에 저장돼 있다. 이미지를 제공하는 저장소를 레지스트리(registry)라고 하는데, 도커 허브는 무료로 제공되는 공개 레지스트리다.

`docker image pull` 명령을 실행해 출력된 내용 중 흥미로운 부분은 이미지가 저장된 방식을 짐작케 하는 부분이다. 도커 이미지는 논리적으로는 하나의 대상(애플리케이션 스택 전체가 하나의 파일로 압축된 압축 파일을 생각하면 쉽게 이해할 수 있다.)이다. 이 이미지의 경우 내가 작성한 애플리케이션 코드 외에 Node.js 런타임을 포함한다.

이미지를 내려받는 과정을 보면 여러 건의 파일을 동시에 내려받는다는 점에서 **단일 파일을 내려받는 과정이 아니라는 것을 알 수 있다.** **이들 각각의 파일을 이미지 레이어라고 부른다.** 도커 이미지는 물리적으로는 여러 개의 작은 파일로 구성돼 있다. 그리고 도커가 이들 파일을 조립해 컨테이너의 내부 파일 시스템을 만든다. 모든 레이어를 내려받고 나면 전체 이미지를 사용할 수 있게 된다.

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker container run -d --name web-ping diamol/ch03-web-ping
43ee52b5fdef5b8a648752a54da80228700b2cb3102afd7b052bd1e02f295e1d
```

`-d` 플래그는 `--detach`의 축약형이다. 그러므로 이 컨테이너는 백그라운드에서 동작한다. 애플리케이션 역시 사용자 인터페이스 없이 배치 잡(batch job)처럼 동작한다. 그러나 2장에서 실행했던 웹 사이트 컨테이너와 달리, 이 컨테이너는 네트워크를 통해 요청을 받지 않는다. 그러므로 포트를 외부로 공개할 필요도 없다.

이 명령에는 처으보는 플래그 `--name`이 있다. 지금까지 컨테이너를 조작하려면 처음 실행할 때 임의로 생성된 컨테이너 ID를 입력해 대상 컨테이너를 지정해 주어야 했다. 그러나 `--name` 플래그를 사용하면 컨테이너에 원하는 이름을 붙이고 이 이름으로 컨테이너를 지칭할 수 있다.

무한 루프를 돌며 실행되는 애플리케이션이므로 2장에서 배운 `docker container` 명령을 통해 컨테이너의 상태를 확인할 수도 있다.

```c
docker container logs web-ping

Got response status: 200 at 1768058126334; duration: 24ms
Making request number: 4729; at 1768058129315
Got response status: 200 at 1768058129343; duration: 28ms
Making request number: 4730; at 1768058132323
Got response status: 200 at 1768058132352; duration: 29ms
Making request number: 4731; at 1768058135330
Got response status: 200 at 1768058135362; duration: 32ms
Making request number: 4732; at 1768058138338
Got response status: 200 at 1768058138450; duration: 112ms
Making request number: 4733; at 1768058141344
Got response status: 200 at 1768058141384; duration: 40ms
Making request number: 4734; at 1768058144350
Got response status: 200 at 1768058144405; duration: 55ms
Making request number: 4735; at 1768058147358
Got response status: 200 at 1768058147395; duration: 37ms
Making request number: 4736; at 1768058150364
Got response status: 200 at 1768058150393; duration: 29ms
Making request number: 4737; at 1768058153369
Got response status: 200 at 1768058153418; duration: 49ms
Making request number: 4738; at 1768058156373
Got response status: 200 at 1768058156411; duration: 38ms
Making request number: 4739; at 1768058159382
Got response status: 200 at 1768058159410; duration: 28ms
Making request number: 4740; at 1768058162390
Got response status: 200 at 1768058162427; duration: 37ms
Making request number: 4741; at 1768058165398
Got response status: 200 at 1768058165432; duration: 34ms
Making request number: 4742; at 1768058168403
Got response status: 200 at 1768058168448; duration: 45ms
Making request number: 4743; at 1768058171404
Got response status: 200 at 1768058171429; duration: 25ms
Making request number: 4744; at 1768058174408
Got response status: 200 at 1768058174439; duration: 31ms
Making request number: 4745; at 1768058177416
Got response status: 200 at 1768058177450; duration: 34ms
Making request number: 4746; at 1768058180425
Got response status: 200 at 1768058180458; duration: 33ms
Making request number: 4747; at 1768058183434
Got response status: 200 at 1768058183462; duration: 28ms
```

환경변수는 운영체제에서 제공하는 키-값 쌍이다. 윈도우나 리눅스나 같은 방식으로 동작하며, 아주 적은 양의 데이터를 저장하는데 유용하다. 도커 컨테이너도 별도의 환경 변수를 가질 수 있다. 그러나 이 환경 변수는 호스트 운영체제의 것을 가져오는게 아니라 컨테이너의 호스트 명이나 IP 주소처럼 도커가 부여해 준다.

web-ping 이미지에도 이 환경 변수의 기본값이 포함돼 있다. 컨테이너를 실행하면 도커가 이들 기본값을 컨테이너에 적용하고 이 값을 애플리케이션에서 사용한다. 컨테이너를 생성할 때 기본값과 다른 값을 환경 변수로 설정할 수도 있다. 환경 변수값을 변경하면 애플리케이션의 동작 내용도 바뀐다.

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker container run --env TARGET=google.com diamol/ch03-web-ping
** web-ping ** Pinging: google.com; method: HEAD; 3000ms intervals
Making request number: 1; at 1768058478654
Got response status: 301 at 1768058478903; duration: 249ms
Making request number: 2; at 1768058481660
Got response status: 301 at 1768058481821; duration: 161ms
Making request number: 3; at 1768058484669
Got response status: 301 at 1768058484850; duration: 181ms
```

새로 시작한 컨테이너의 동작은 아까와는 다르다. 첫 번째 차이점으로, 이 컨테이너는 `--detach` 플래그를 적용하지 않았으므로 애플리케이션의 출력 내용이 콘솔에 나타난다. 두번째 차이점은 HTTP 요청을 보내는 대상이 blog.sixeyed.com에서 google.com으로 변경됐다는 것이다.

이 부분이 이번 장에서 가장 중요한 부분이다. 도커 이미지는 설정값의 기본값을 포함해 패키징되지만, 컨테이너를 실행할 때 이 설정값을 바꿀 수 있어야 한다.

호스트 컴퓨터에도 고유의 환경 변수가있다. 그러나 호스트 컴퓨터의 환경 변수는 컨테이너와는 별개다. 컨테이너는 도커가 부여한 환경 변수만을 갖는다.

# 3.2 Dockerfile 작성하기

Dockerfile은 애플리케이션을 패키징하기 위한 간단한 스크립트다. Dockerfile은 일련의 인스트럭션으로 구성돼 있는데, 인스트럭션을 실행한 결과로 도커 이미지가 만들어진다. Dockerfile 문법은 배우기 쉬우며 어떠한 애플리케이션이라도 패키징 할 수 있다. 여타 스크립트 언어와 마찬가지로 Dockerfile 문법도 매우 유연하다. 자주 쓰이는 작업은 별도의 명령이 마련돼 있으며, 원하는 작업을 직접 작성할 수 있고, 표준 셸 문법도 사용 가능하다. (리눅스의 배시 셸 혹은 윈도의 파워셸)

# 3.3 컨테이너 이미지 빌드하기

이미지를 빌드하려면 이미지의 이름, 패키징에 필요한 파일의 경로를 추가로 지정해주어야 한다.

```c
docker image build --tag web-ping .
```

`--tag`의 인잣값(web-ping)은 이미지의 이름이고, 이어지는 인자는 Dockerfile 및 이미지에 포함시킬 파일이 위치한 경로다. **도커에서는 이 디렉터리를 컨텍스트라고 한다.** 마지막의 `.`은 ‘현재 작업 디렉터리’라는 뜻이다. build 명령을 입력하면 Dockerfile 스크립트에 포함된 인스트럭션이 차례로 실행되며 그 결과가 출력된다.

**파일 권한과 관련된 경고 메시지가 출력된다면 윈도 환경에서 리눅스 컨테이너를 빌드하려고 했기 때문이다.** 윈도용 도커 데스크톱에는 리눅스 컨테이너 모드가 있어서 리눅스컨테이너를 빌드할 수 있다. 다만 윈도에서는 파일 권한을 설정하는 방법이 리눅스와 다르기 때문에 **윈도 환경에서 빌드된 리눅스 컨테이너 이미지의 파일은 모두 읽고 쓰기가 전면 허용되는 상태가 된다.**
