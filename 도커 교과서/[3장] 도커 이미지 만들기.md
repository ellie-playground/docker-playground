# 3.1 도커 허브에 공유된 이미지 사용하기

2장에서 `docker container run` 명령을 사용할 때 필요한 이미지 중 로컬 컴퓨터에 없는 이미지가 있으면 이미지를 내려받는 과정을 봤을 것이다. 이 과정은 소프트웨어 배포 기능이 도커 플랫폼에 완전히 내장됐기 때문에 가능했다. 이미지를 내려받는 과정을 이처럼 도커에 전적으로 맡길 수도 있지만, 도커 cli를 통해 명시적으로 원하는 이미지를 내려받을 수도 있다.

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker image pull diamol/ch03-web-ping
Using default tag: latest
latest: Pulling from diamol/ch03-web-ping
0362ad1dd800: Pull complete 
b09a182c47e8: Pull complete 
39d61d2ed871: Pull complete 
b4e2115e274a: Pull complete 
f5cca017994f: Pull complete 
f504555623f6: Pull complete 
Digest: sha256:2f2dce710a7f287afc2d7bbd0d68d024bab5ee37a1f658cef46c64b1a69affd2
Status: Downloaded newer image for diamol/ch03-web-ping:latest
docker.io/diamol/ch03-web-ping:latest
```

이미지 이름은 diamol/ch03-web-ping 이고, 이 이미지는 도커가 가장 먼저 이미지를 찾기 위해 접근하는 저장소인 도커 허브에 저장돼 있다. 이미지를 제공하는 저장소를 레지스트리(registry)라고 하는데, 도커 허브는 무료로 제공되는 공개 레지스트리다.

`docker image pull` 명령을 실행해 출력된 내용 중 흥미로운 부분은 이미지가 저장된 방식을 짐작케 하는 부분이다. 도커 이미지는 논리적으로는 하나의 대상(애플리케이션 스택 전체가 하나의 파일로 압축된 압축 파일을 생각하면 쉽게 이해할 수 있다.)이다. 이 이미지의 경우 내가 작성한 애플리케이션 코드 외에 Node.js 런타임을 포함한다.

이미지를 내려받는 과정을 보면 여러 건의 파일을 동시에 내려받는다는 점에서 **단일 파일을 내려받는 과정이 아니라는 것을 알 수 있다.** **이들 각각의 파일을 이미지 레이어라고 부른다.** 도커 이미지는 물리적으로는 여러 개의 작은 파일로 구성돼 있다. 그리고 도커가 이들 파일을 조립해 컨테이너의 내부 파일 시스템을 만든다. 모든 레이어를 내려받고 나면 전체 이미지를 사용할 수 있게 된다.

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker container run -d --name web-ping diamol/ch03-web-ping
43ee52b5fdef5b8a648752a54da80228700b2cb3102afd7b052bd1e02f295e1d
```

`-d` 플래그는 `--detach`의 축약형이다. 그러므로 이 컨테이너는 백그라운드에서 동작한다. 애플리케이션 역시 사용자 인터페이스 없이 배치 잡(batch job)처럼 동작한다. 그러나 2장에서 실행했던 웹 사이트 컨테이너와 달리, 이 컨테이너는 네트워크를 통해 요청을 받지 않는다. 그러므로 포트를 외부로 공개할 필요도 없다.

이 명령에는 처으보는 플래그 `--name`이 있다. 지금까지 컨테이너를 조작하려면 처음 실행할 때 임의로 생성된 컨테이너 ID를 입력해 대상 컨테이너를 지정해 주어야 했다. 그러나 `--name` 플래그를 사용하면 컨테이너에 원하는 이름을 붙이고 이 이름으로 컨테이너를 지칭할 수 있다.
