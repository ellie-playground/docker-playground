# 3.1 도커 허브에 공유된 이미지 사용하기

2장에서 `docker container run` 명령을 사용할 때 필요한 이미지 중 로컬 컴퓨터에 없는 이미지가 있으면 이미지를 내려받는 과정을 봤을 것이다. 이 과정은 소프트웨어 배포 기능이 도커 플랫폼에 완전히 내장됐기 때문에 가능했다. 이미지를 내려받는 과정을 이처럼 도커에 전적으로 맡길 수도 있지만, 도커 cli를 통해 명시적으로 원하는 이미지를 내려받을 수도 있다.

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker image pull diamol/ch03-web-ping
Using default tag: latest
latest: Pulling from diamol/ch03-web-ping
0362ad1dd800: Pull complete 
b09a182c47e8: Pull complete 
39d61d2ed871: Pull complete 
b4e2115e274a: Pull complete 
f5cca017994f: Pull complete 
f504555623f6: Pull complete 
Digest: sha256:2f2dce710a7f287afc2d7bbd0d68d024bab5ee37a1f658cef46c64b1a69affd2
Status: Downloaded newer image for diamol/ch03-web-ping:latest
docker.io/diamol/ch03-web-ping:latest
```

이미지 이름은 diamol/ch03-web-ping 이고, 이 이미지는 도커가 가장 먼저 이미지를 찾기 위해 접근하는 저장소인 도커 허브에 저장돼 있다. 이미지를 제공하는 저장소를 레지스트리(registry)라고 하는데, 도커 허브는 무료로 제공되는 공개 레지스트리다.

`docker image pull` 명령을 실행해 출력된 내용 중 흥미로운 부분은 이미지가 저장된 방식을 짐작케 하는 부분이다. 도커 이미지는 논리적으로는 하나의 대상(애플리케이션 스택 전체가 하나의 파일로 압축된 압축 파일을 생각하면 쉽게 이해할 수 있다.)이다. 이 이미지의 경우 내가 작성한 애플리케이션 코드 외에 Node.js 런타임을 포함한다.

이미지를 내려받는 과정을 보면 여러 건의 파일을 동시에 내려받는다는 점에서 **단일 파일을 내려받는 과정이 아니라는 것을 알 수 있다.** **이들 각각의 파일을 이미지 레이어라고 부른다.** 도커 이미지는 물리적으로는 여러 개의 작은 파일로 구성돼 있다. 그리고 도커가 이들 파일을 조립해 컨테이너의 내부 파일 시스템을 만든다. 모든 레이어를 내려받고 나면 전체 이미지를 사용할 수 있게 된다.

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker container run -d --name web-ping diamol/ch03-web-ping
43ee52b5fdef5b8a648752a54da80228700b2cb3102afd7b052bd1e02f295e1d
```

`-d` 플래그는 `--detach`의 축약형이다. 그러므로 이 컨테이너는 백그라운드에서 동작한다. 애플리케이션 역시 사용자 인터페이스 없이 배치 잡(batch job)처럼 동작한다. 그러나 2장에서 실행했던 웹 사이트 컨테이너와 달리, 이 컨테이너는 네트워크를 통해 요청을 받지 않는다. 그러므로 포트를 외부로 공개할 필요도 없다.

이 명령에는 처으보는 플래그 `--name`이 있다. 지금까지 컨테이너를 조작하려면 처음 실행할 때 임의로 생성된 컨테이너 ID를 입력해 대상 컨테이너를 지정해 주어야 했다. 그러나 `--name` 플래그를 사용하면 컨테이너에 원하는 이름을 붙이고 이 이름으로 컨테이너를 지칭할 수 있다.

무한 루프를 돌며 실행되는 애플리케이션이므로 2장에서 배운 `docker container` 명령을 통해 컨테이너의 상태를 확인할 수도 있다.

```c
docker container logs web-ping

Got response status: 200 at 1768058126334; duration: 24ms
Making request number: 4729; at 1768058129315
Got response status: 200 at 1768058129343; duration: 28ms
Making request number: 4730; at 1768058132323
Got response status: 200 at 1768058132352; duration: 29ms
Making request number: 4731; at 1768058135330
Got response status: 200 at 1768058135362; duration: 32ms
Making request number: 4732; at 1768058138338
Got response status: 200 at 1768058138450; duration: 112ms
Making request number: 4733; at 1768058141344
Got response status: 200 at 1768058141384; duration: 40ms
Making request number: 4734; at 1768058144350
Got response status: 200 at 1768058144405; duration: 55ms
Making request number: 4735; at 1768058147358
Got response status: 200 at 1768058147395; duration: 37ms
Making request number: 4736; at 1768058150364
Got response status: 200 at 1768058150393; duration: 29ms
Making request number: 4737; at 1768058153369
Got response status: 200 at 1768058153418; duration: 49ms
Making request number: 4738; at 1768058156373
Got response status: 200 at 1768058156411; duration: 38ms
Making request number: 4739; at 1768058159382
Got response status: 200 at 1768058159410; duration: 28ms
Making request number: 4740; at 1768058162390
Got response status: 200 at 1768058162427; duration: 37ms
Making request number: 4741; at 1768058165398
Got response status: 200 at 1768058165432; duration: 34ms
Making request number: 4742; at 1768058168403
Got response status: 200 at 1768058168448; duration: 45ms
Making request number: 4743; at 1768058171404
Got response status: 200 at 1768058171429; duration: 25ms
Making request number: 4744; at 1768058174408
Got response status: 200 at 1768058174439; duration: 31ms
Making request number: 4745; at 1768058177416
Got response status: 200 at 1768058177450; duration: 34ms
Making request number: 4746; at 1768058180425
Got response status: 200 at 1768058180458; duration: 33ms
Making request number: 4747; at 1768058183434
Got response status: 200 at 1768058183462; duration: 28ms
```

환경변수는 운영체제에서 제공하는 키-값 쌍이다. 윈도우나 리눅스나 같은 방식으로 동작하며, 아주 적은 양의 데이터를 저장하는데 유용하다. 도커 컨테이너도 별도의 환경 변수를 가질 수 있다. 그러나 이 환경 변수는 호스트 운영체제의 것을 가져오는게 아니라 컨테이너의 호스트 명이나 IP 주소처럼 도커가 부여해 준다.

web-ping 이미지에도 이 환경 변수의 기본값이 포함돼 있다. 컨테이너를 실행하면 도커가 이들 기본값을 컨테이너에 적용하고 이 값을 애플리케이션에서 사용한다. 컨테이너를 생성할 때 기본값과 다른 값을 환경 변수로 설정할 수도 있다. 환경 변수값을 변경하면 애플리케이션의 동작 내용도 바뀐다.

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker container run --env TARGET=google.com diamol/ch03-web-ping
** web-ping ** Pinging: google.com; method: HEAD; 3000ms intervals
Making request number: 1; at 1768058478654
Got response status: 301 at 1768058478903; duration: 249ms
Making request number: 2; at 1768058481660
Got response status: 301 at 1768058481821; duration: 161ms
Making request number: 3; at 1768058484669
Got response status: 301 at 1768058484850; duration: 181ms
```

새로 시작한 컨테이너의 동작은 아까와는 다르다. 첫 번째 차이점으로, 이 컨테이너는 `--detach` 플래그를 적용하지 않았으므로 애플리케이션의 출력 내용이 콘솔에 나타난다. 두번째 차이점은 HTTP 요청을 보내는 대상이 blog.sixeyed.com에서 google.com으로 변경됐다는 것이다.

이 부분이 이번 장에서 가장 중요한 부분이다. 도커 이미지는 설정값의 기본값을 포함해 패키징되지만, 컨테이너를 실행할 때 이 설정값을 바꿀 수 있어야 한다.

호스트 컴퓨터에도 고유의 환경 변수가있다. 그러나 호스트 컴퓨터의 환경 변수는 컨테이너와는 별개다. 컨테이너는 도커가 부여한 환경 변수만을 갖는다.

# 3.2 Dockerfile 작성하기

Dockerfile은 애플리케이션을 패키징하기 위한 간단한 스크립트다. Dockerfile은 일련의 인스트럭션으로 구성돼 있는데, 인스트럭션을 실행한 결과로 도커 이미지가 만들어진다. Dockerfile 문법은 배우기 쉬우며 어떠한 애플리케이션이라도 패키징 할 수 있다. 여타 스크립트 언어와 마찬가지로 Dockerfile 문법도 매우 유연하다. 자주 쓰이는 작업은 별도의 명령이 마련돼 있으며, 원하는 작업을 직접 작성할 수 있고, 표준 셸 문법도 사용 가능하다. (리눅스의 배시 셸 혹은 윈도의 파워셸)

# 3.3 컨테이너 이미지 빌드하기

이미지를 빌드하려면 이미지의 이름, 패키징에 필요한 파일의 경로를 추가로 지정해주어야 한다.

```c
docker image build --tag web-ping .
```

`--tag`의 인잣값(web-ping)은 이미지의 이름이고, 이어지는 인자는 Dockerfile 및 이미지에 포함시킬 파일이 위치한 경로다. **도커에서는 이 디렉터리를 컨텍스트라고 한다.** 마지막의 `.`은 ‘현재 작업 디렉터리’라는 뜻이다. build 명령을 입력하면 Dockerfile 스크립트에 포함된 인스트럭션이 차례로 실행되며 그 결과가 출력된다.

**파일 권한과 관련된 경고 메시지가 출력된다면 윈도 환경에서 리눅스 컨테이너를 빌드하려고 했기 때문이다.** 윈도용 도커 데스크톱에는 리눅스 컨테이너 모드가 있어서 리눅스컨테이너를 빌드할 수 있다. 다만 윈도에서는 파일 권한을 설정하는 방법이 리눅스와 다르기 때문에 **윈도 환경에서 빌드된 리눅스 컨테이너 이미지의 파일은 모두 읽고 쓰기가 전면 허용되는 상태가 된다.**

출력 마지막에 ‘successfully built’, ‘successfully tagged’ 라는 메시지가 나왔다면, 이미지를 성공적으로 빌드한 것이다. 빌드된 이미지는 로컬 이미지 캐시에 저장되며, 도커 명령으로 이미지 목록을 확인하면 볼 수 있다.

```c
docker image ls 'w*'
```

이 명령을 입력하면 다음과 같이 web-ping 이미지를 확인할 수 있다.

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker image ls 'm*'
REPOSITORY   TAG       IMAGE ID       CREATED       SIZE
mysql        8.0.33    a5e6f938c138   2 years ago   587MB
```

이렇게 빌드된 이미지는 도커 허브에서 내려받은 이미지와 똑같이 사용할 수 있다. 이미지에 포함된 애플리케이션도 같고, 환경 변수를 이용한 설정도 같은 방법으로 할 수 있다.

```c
docker container run -e TARGET=docker.com -e INTERVAL=5000 web-ping
```

위 명령을 입력하면 그림 3-7과 비슷한 내용이 출력된다. 출력된 로그의 첫 번째 줄에서 대상 URL이 docker.com이고 요청 간격이 5000 밀리세컨드로 설정된 것을 확인할 수 있다.

# 3.4 도커 이미지와 이미지 레이어 이해하기

도커 이미지에는 우리가 패키징에 포함시킨 모든 파일이 들어 있다. 이들 파일은 나중에 컨테이너의 파일 시스템을 형성한다. 이 외에도 이미지에는 자신에 대한 여러 메타데이터 정보도 들어 있다. 이 정보 중에는 이미지가 어떻게 빌드됐는지에 대한 간단한 이력도 포함된다. 이 정보를 이용하면 이미지를 구성하는 각 레이어는 무엇이고 이들 레이어가 어떤 명령으로 빌드됐는지 알 수 있다.

```c
hee@yuhuijin-ui-MacBookAir lab % docker image history web-ping
IMAGE          CREATED          CREATED BY                                      SIZE      COMMENT
a5b350fa1a90   48 seconds ago   COPY ch03.txt . # buildkit                      18B       buildkit.dockerfile.v0
<missing>      48 seconds ago   WORKDIR /diamol                                 0B        buildkit.dockerfile.v0
<missing>      4 years ago      /bin/sh -c apk add --no-cache curl              1.59MB    
<missing>      5 years ago      /bin/sh -c #(nop)  CMD ["/bin/sh"]              0B        
<missing>      5 years ago      /bin/sh -c #(nop) ADD file:da3ddeca2212f561c…   5.3MB  
```

이 명령을 입력하면 한 줄마다 한 레이어에 대한 정보가 출력된다. `CREATED BY` 항목은 해당 레이어를 구성한 Dockerfile 스크립트의 인스트럭션(명령어)이다. Dockerfile 인스트럭션과 이미지 레이어는 1:1 관계를 갖는다. 

도커 이미지는 이미지 레이어가 모인 논리적 대상이다. 레이어는 도커 엔진의 캐시에 물리적으로 저장된 파일이다. 이 점이 왜 중요하냐면, **이미지 레이어는 여러 이미지와 컨테이너에서 공유되기 때문이다.** 만약 Node.js 애플리케이션이 실행되는 컨테이너를 여러 개 실행한다면 **이들 컨테이너는 모두 Node.js 런타임이 들어있는 이미지 레이어를 공유한다.**

`diamol/node` 이미지는 최소한의 운영체제 레이어와 Node.js 런타임을 포함한다. 리눅스 이미지는 약 75MB의 디스크 용량을 차지한다.(윈도의 운영체제 기반 레이어는 이보다 크기 때문에 윈도 버전은 약 300MB 정도가 된다.) 우리가 만든 `web-ping` 이미지는 `diamol/node` 이미지를 기반 이미지로 하므로 기반 이미지의 모든 레이어를 포함한다. Dockerfile 스크립트의 `FROM` 인스트럭션의 의미가 바로 이것이다. 기반 레이어 위에 추가한 app.js 파일은 불과 몇 KB에 지나지 않는다.

`docker image ls`로 출력된 이미지 목록에서 각 이미지의 용량을 확인할 수 있다.

```c
hee@yuhuijin-ui-MacBookAir lab % docker image ls
REPOSITORY      TAG               IMAGE ID       CREATED         SIZE
web-ping        latest            a5b350fa1a90   9 minutes ago   6.89MB
dada-app        latest            c7186074a913   2 days ago      351MB
moby/buildkit   buildx-stable-1   02feb29841fc   6 weeks ago     223MB
mysql           8.0.33            a5e6f938c138   2 years ago     587MB
```

언뜻 보면 `diamol/node`, 도커 허브에서 내려받은 `diamol/ch03-web-ping`, 그리고 새로 빌드한 `web-ping`까지 세 이미지가 모두 비슷한 용량을 점유하는 것처럼 보인다. (리눅스 버전의 경우 약 75MB) 분명 기반 레이어를 공유할 텐데, `docker image ls` 명령으로 출력된 결과는 각각 75MB 씩 도합 225MB의 디스크 용량을 점유하는 것으로 나온다.

하지만 이는 사실이 아니다. **이미지 목록의 SIZE 항목에 나오는 수치는 이미지의 논리적 용량이지 해당 이미지가 실제로 차지하는 디스크 용량을 나타내는 것이 아니다.** 다른 이미지와 레이어를 공유하면 여기에 나온 수치보다 디스크 용량을 훨씬 덜 차지한다. 이미지 목록 확인에서는 이를 확인할 수 없지만, 다른 명령으로 확인할 수 있다.

```c
hee@yuhuijin-ui-MacBookAir lab % docker system df
TYPE            TOTAL     ACTIVE    SIZE      RECLAIMABLE
Images          4         3         1.169GB   6.89MB (0%)
Containers      3         2         2.404kB   2.398kB (99%)
Local Volumes   2         2         1.683GB   0B (0%)
Build Cache     7         0         67B       67B
```

이미지 저장에 실제 사용된 디스크 용량은 `system df` 명령으로 확인할 수 있다. 이 명령을 입력해 나온 출력 결과를 보면 이미지 캐시의 실제 용량은 약 6.89MB를 차지하는 것으로 나온다. 나머지는 이미지끼리 레이어를 공유한 것으로, 약 45%의 디스크 공간이 절약됐다. 이렇게 절약되는 디스크 공간은 대개 런타임 등 같은 기반 레이어를 공유하는 애플리케이션의 숫자가 많을수록 더욱 늘어난다. 이들 기반 레이어가 자바, 닷넷, PHP 그 무엇이든 도커의 동작 방식은 같다.

**이미지 레이어를 여러 이미지가 공유한다면, 공유되는 레이어는 수정할 수 없어야 한다.** 만약 이미지의 레이어를 수정할 수 있다면 그 수정이 레이어를 공유하는 다른 이미지에도 영향을 미치게 된다. **도커는 이미지 레이어를 읽기 전용으로 만들어 두어 이런 문제를 방지한다.** 이미지를 빌드하면서 레이어가 만들어지면 레이어는 다른 이미지에서 재사용될 수 있다. 그러나 레이어를 수정할 수는 없다.

# 3.5 이미지 레이어 캐시를 이용한 Dockerfile 스크립트 최적화

우리가 조금 전에 빌드한 `web-ping` 이미지에는 애플리케이션이 구현된 자바스크립트 파일이 들어있다. 이 파일을 수정하고 이미지를 다시 빌드하면, 새로운 이미지 레이어가 생긴다. **도커의 이미지 레이어가 특정한 순서대로만 배치된다고 가정한다. 그래서 이 순서 중간에 있는 레이어가 변경되면 변경된 레이어보다 위에 오는 레이어를 재사용할 수 없다.**

```c
hee@yuhuijin-ui-MacBookAir web-ping % docker image build --tag web-ping .
[+] Building 6.7s (8/8) FINISHED                                                                                                                                                
 => [internal] load build definition from Dockerfile                                                                                                                       0.0s
 => => transferring dockerfile: 196B                                                                                                                                       0.0s
 => [internal] load .dockerignore                                                                                                                                          0.0s
 => => transferring context: 2B                                                                                                                                            0.0s
 => [internal] load metadata for docker.io/diamol/node:latest                                                                                                              2.7s
 => [1/3] FROM docker.io/diamol/node@sha256:dfee522acebdfdd9964aa9c88ebebd03a20b6dd573908347be3ebf52ac4879c8                                                               3.7s
 => => resolve docker.io/diamol/node@sha256:dfee522acebdfdd9964aa9c88ebebd03a20b6dd573908347be3ebf52ac4879c8                                                               0.0s
 => => sha256:dfee522acebdfdd9964aa9c88ebebd03a20b6dd573908347be3ebf52ac4879c8 1.41kB / 1.41kB                                                                             0.0s
 => => sha256:6467efe6481aace0c317f144079c1a321b91375a828dbdb59b363a2aef78b33b 1.16kB / 1.16kB                                                                             0.0s
 => => sha256:8e0eeb0a11b3a91cc1d91b5ef637edd153a64a3792e08a3f8d0702ec4f01a9e7 5.66kB / 5.66kB                                                                             0.0s
 => => sha256:0362ad1dd800a9d92f8982fa28f173f9120266153830f990f7486f44b068968a 2.69MB / 2.69MB                                                                             0.5s
 => => sha256:b09a182c47e8fe10485c6004679511c185b1d7c6984dcc44c9574ddcc23baa8b 21.58MB / 21.58MB                                                                           2.2s
 => => sha256:39d61d2ed87191c75ea7d607157d6412816da2762b27b51ecd2bca5da513ec92 1.34MB / 1.34MB                                                                             2.5s
 => => extracting sha256:0362ad1dd800a9d92f8982fa28f173f9120266153830f990f7486f44b068968a                                                                                  0.3s
 => => sha256:b4e2115e274ad73e48777b4d8523035a0b61c0a7f6c8391e1ee4c020cbff1f72 280B / 280B                                                                                 0.8s
 => => extracting sha256:b09a182c47e8fe10485c6004679511c185b1d7c6984dcc44c9574ddcc23baa8b                                                                                  1.1s
 => => extracting sha256:39d61d2ed87191c75ea7d607157d6412816da2762b27b51ecd2bca5da513ec92                                                                                  0.1s
 => => extracting sha256:b4e2115e274ad73e48777b4d8523035a0b61c0a7f6c8391e1ee4c020cbff1f72                                                                                  0.0s
 => [internal] load build context                                                                                                                                          0.0s
 => => transferring context: 884B                                                                                                                                          0.0s
 => [2/3] WORKDIR /web-ping                                                                                                                                                0.2s
 => [3/3] COPY app.js .                                                                                                                                                    0.0s
 => exporting to image                                                                                                                                                     0.0s
 => => exporting layers                                                                                                                                                    0.0s
 => => writing image sha256:75f2a0ecba27b06d7296ca34680e066ad47370fc4c576749d064452edb517f4b                                                                               0.0s
 => => naming to docker.io/library/web-ping               
```
