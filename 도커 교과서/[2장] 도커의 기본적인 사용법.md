# 2.1 컨테이너로 Hello World 실행하기

```c
hee@yuhuijin-ui-MacBookAir hello-diamol % docker container run diamol/ch02-hello-diamol
Unable to find image 'diamol/ch02-hello-diamol:latest' locally
latest: Pulling from diamol/ch02-hello-diamol
941f399634ec: Pull complete 
93931504196e: Pull complete 
d7b1f3678981: Pull complete 
Digest: sha256:c4f45e04025d10d14d7a96df2242753b925e5c175c3bea9112f93bf9c55d4474
Status: Downloaded newer image for diamol/ch02-hello-diamol:latest
---------------------
Hello from Chapter 2!
---------------------
My name is:    # 컴퓨터의 이름
91cc19465791
---------------------
Im running on:
Linux 5.15.49-linuxkit aarch64     # 운영체제 종류
---------------------
My address is:     # 네트워크 주소
inet addr:172.17.0.2 Bcast:172.17.255.255 Mask:255.255.0.0
---------------------
```

`docker container run` **명령은 컨테이너로 애플리케이션을 실행하라는 도커 명령이다.** 이 애플리케이션은 미리 도커로 실행하도록 패키징돼 누구나 내려받을 수 있도록 공유된 것이다. 이 컨테이너 패키지(도커에서는 이를 ‘이미지’라고 한다)의 이름은 `diamol/ch02-hello-diamol` 이다. 그리고 지금 입력한 명령이 이미지를 이용해 컨테이너를 실행하는 도커 명령이다.

이미지를 이용해 컨테이너를 실행하려면 먼저 이미지가 있어야 한다. 조금 전의 명령을 처음 실행했던 시점에는 우리가 이미지를 갖고 있지 않았다. 그래서 출력 메시지 처음 부분에 unable to find image locally라는 메시지가 출력된 것이다. 그리고 이어서 도커가 이미지를 내려받는(도커에서 이미지를 내려받는 것을 pull이라고 한다)과정을 볼 수 있다.

이미지를 내려받고 나면 내려받은 이미지를 사용해 컨테이너를 실행한다. 이미지에는 애플리케이션을 실행하는데 필요한 모든 내용과 함께 애플리케이션을 실행하는 방법이 정의돼 있다.

아주 간단한 애플리케이션이지만 이 과정에서 도커를 사용하는 워크플로의 핵심을 볼 수 있다. 먼저 애플리케이션을 컨테이너에서 실행할 수 있도록 패키징하고, 다른 사람이 패키지를 사용할 수 있도록 공유한 다음, 이 패키지를 내려받은 사람이 컨테이너를 통해 애플리케이션을 실행하는 것이다. 도커에서는 이 과정을 빌드, 공유, 실행이라고 부른다.

빌드, 공유, 실행은 매우 강력한 개념이다. 아무리 복잡한 애플리케이션이라도 모두 이 과정을 거치기 때문이다. 그리고 도커를 실행할 수 있는 환경이라면 어디서든 실행할 수 있도록 도커 이미지를 만들 수 있다. 이런 방법으로 도커의 핵심적인 이점인 이식성이 확보된다.

```c
hee@yuhuijin-ui-MacBookAir hello-diamol % docker container run diamol/ch02-hello-diamol
---------------------
Hello from Chapter 2!
---------------------
My name is:
476c9a32660a
---------------------
Im running on:
Linux 5.15.49-linuxkit aarch64
---------------------
My address is:
inet addr:172.17.0.2 Bcast:172.17.255.255 Mask:255.255.0.0
```

같은 명령을 한번 더 입력해 또 다른 컨테이너를 실행하면 어떻게 될까? 아까와 비슷하지만 조금 다른 내용이 출력된다. 도커가 조금 전 이미지를 이미 내려받았기 때문에 이미지를 내려받는 부분이 사라지고 바로 컨테이너를 실행하는 메시지가 출력된다. 같은 컴퓨터를 사용하므로 컨테이너가 출력하는 내용 중 운영체제와 아키텍처에 대한 내용은 아까와 같으며, 컴퓨터 이름과 네트워크 주소에 대한 내용은 달라진다.

컴퓨터 이름은 컨테이너를 실행할 때마다 매번 바뀌며, IP 주소 역시 매번 바뀔 확률이 높다. 그런데 모든 컨테이너는 같은 컴퓨터에서 실행될텐데 컴퓨터 이름과 IP 주소가 왜 계속 바뀌는 것일까?

# 2.2 컨테이너란 무엇인가?

도커 컨테이너는 말 그대로 물건을 담는 컨테이너와 다를 것이 없다. 애플리케이션이 들어 있는 어떤 상자를 상상해보자. 이 상자 안에는 애플리케이션과 애플리케이션을 실행할 컴퓨터가 함께 들어있다.

호스트명, IP 주소, 파일 시스템까지 이들은 모두 도커가 만들어낸 가상 리소스다. 이들이 서로 엮여 애플리케이션이 동작할 수 있는 환경이 만들어진다. 이 환경이 바로 그림 2-2의 ‘상자’다. 상자 안에서는 상자 밖의 환경을 볼 수 없다. 그러나 이 상자는 어떤 컴퓨터상에서 동작하는 것이고, 이 컴퓨터는 이 상자 말고도 다른 상자를 여러개 실행할 수 있다. 이들 상자는 서로 독립적인 환경을 갖지만 상자가 실행되는 컴퓨터의 CPU와 메모리, 운영체제를 공유한다.

이러한 구도가 중요한 이유는 **격리와 밀집이라는 얼핏 보면 모순돼보이는 조건을 동시에 만족할 수 있기 때문이다.** **밀집이란 컴퓨터에 CPU와 메모리가 허용하는 한 되도록 많은 수의 애플리케이션을 실행하는 것을 의미**한다. 그러나 서로 다른 여러 애플리케이션을 동시에 실행하는 데는 제약이 따른다. 자바나 닷넷 등 필요로하는 런타임의 버전이 서로 다를 수도 있고, 서로 호환되지 않는 버전의 라이브러리를 사용하는가 하면, 어느 한 애플리케이션이 과다한 리소스를 필요로 해 다른 애플리케이션의 리소스가 부족해질 수도 있다. 이런 면을 고려하면 **애플리케이션은 서로 독립된 환경에서 실행돼야 한다.** 하지만 그럴 경우 한 컴퓨터에서 여러 애플리케이션을 실행할 수 없게 되고, 다시 말해 밀집을 달성할 수 없다.

이 모순된 조건을 동시 달성하려던 첫 번째 시도는 가상 머신을 사용하는 것이었다. 가상 머신은 애플리케이션이 실행될 독립적 환경이 생긴다는 점에서는 컨테이너와 큰 차이가 없다. **다만 가상 머신은 컨테이너와 달리 호스트 컴퓨터의 운영체제를 공유하지 않고 별도의 운영체제를 필요로 한다.** 각각의 가상머신은 자신만의 운영체제를 별도로 갖는다. 이 운영체제는 애플리케이션이 사용해야 할 CPU와 메모리 자원을 상당량 차지한다. 운영체제의 라이선스 비용과 운영체제 업데이트 설치 부담이 추가로 생긴다. 결국 **가상 머신은 격리는 달성할 수 있지만 밀집은 제공하지 못한다.**

컨테이너는 이러한 단점을 해결할 수 있다. 각각의 컨테이너는 호스트 컴퓨터의 운영체제를 공유하므로 필요한 리소스가 크게 경감된다. 그만큼 실행도 빠르고 같은 호스트 컴퓨터에서 가상 머신에 비해 더 많은 수의 애플리케이션을 실행할 수 있다. 또한, 컨테이너 역시 외부와 독립된 환경을 제공하므로 밀집과 격리가 동시에 달성되는 것이다. 이것이 도커의 또 다른 특징인 효율성이다.

# 2.3 컨테이너를 원격 컴퓨터처럼 사용하기

도커를 사용하면 도구와 스크립트를 하나의 이미지로 패키징해 추가적인 설치나 설정 작업 없이 컨테이너로 스크립트를 바로 실행하게 할 수 있다.

이번에는 컨테이너를 실행하고, 실행된 컨테이너에 마치 원격 컴퓨터에 접속하듯 터미널을 통해 접근해보겠다. 

```c
hee@yuhuijin-ui-MacBookAir hello-diamol % docker run --interactive --tty diamol/base
Unable to find image 'diamol/base:latest' locally
latest: Pulling from diamol/base
941f399634ec: Already exists 
716aca3e500c: Pull complete 
Digest: sha256:787fe221a14f46b55e224ea0436aca77d345c3ded400aaf6cd40125e247f35c7
Status: Downloaded newer image for diamol/base:latest
/ # 

/ # hostname
9b0083306cbd
/ # date
Sat Dec 27 11:50:00 UTC 2025
```

`--interactive` 플래그를 사용하면 컨테이너에 접속된 상태가 된다. 그리고 `--tty` 플래그는 터미널 세션을 통해 컨테이너를 조작하겠다는 의미이다.

원격 컴퓨터에 접속한 것과 같은 로컬 터미널 세션이 열려 있다는 것과 연결된 컴퓨터가 현재 실행 중인 컨테이너라는 것이다. 이를테면 보안 셸(ssh)을 통해 원격 리눅스 컴퓨터에 연결하거나 원격 데스크톱을 통해 다른 윈도 컴퓨터에 연결했다면 지금 컨테이너에 연결한 것과 같은 결과를 얻게 된다.

도커 컨테이너는 호스트 컴퓨터의 운영체제를 공유한다. 그렇기 때문에 호스트 컴퓨터가 리눅스 머신이면 리눅스 셸이 뜨고, 윈도 머신이라면 윈도 명령 프롬프트가 뜨는 것이다.

도커 자체는 호스트 컴퓨터의 아키텍처나 운영체제와 상관없이 동일하게 동작하지만, **컨테이너에 들어 있는 애플리케이션은 운영체제나 아키텍처를 가릴 수 있다. 결국 컨테이너의 내용물이 무엇이든 컨테이너를 다루는 방법은 환경과 상관없이 동일하다. (커널은 공유하기 때문에 완벽하게 격리는 불가능하다.)**

- 컨테이너에 들어있는 애플리케이션은 운영체제나 아키텍처를 가릴 수 있다?
    
    ## 2️⃣ “하지만 컨테이너에 들어 있는 애플리케이션은 OS/아키텍처를 가릴 수 있다”의 의미
    
    이게 핵심이야.
    
    컨테이너 안에는 결국 **실제 실행 파일**이 들어 있음.
    
    ### 🔹 운영체제를 가리는 경우 (OS 의존성)
    
    컨테이너는 **호스트 커널을 공유**해.
    
    그래서:
    
    - Linux 컨테이너 → **Linux 커널 필요**
    - Windows 컨테이너 → **Windows 커널 필요**
    
    즉,
    
    ```
    Linux 호스트 → Linux 컨테이너 가능
    Linux 호스트 → Windows 컨테이너 ❌
    
    ```
    
    컨테이너 안 애플리케이션이:
    
    - glibc
    - /proc
    - 리눅스 시스템콜
    
    같은 걸 쓰면 **리눅스에서만 실행 가능**해.
    
    👉 그래서 **컨테이너 안의 애플리케이션은 OS를 가린다**고 말하는 거야.
    

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker container ls
CONTAINER ID   IMAGE         COMMAND     CREATED        STATUS        PORTS     NAMES
9b0083306cbd   diamol/base   "/bin/sh"   21 hours ago   Up 21 hours             sleepy_pascal
```

위 명령을 실행하면 현재 실행중인 모든 컨테이너에 대한 정보를 볼 수 있다. 컨테이너마다 컨테이너의 바탕이 된 이미지, 컨테이너 ID, 컨테이너 실행 후 도커가 실행한 명령 등이 출력된다.

**지금 출력된 컨테이너 ID가 조금 전에 컨테이너 내부에서 확인한 호스트명과 동일하다는 사실을 알 수 있다.** 도커는 컨테이너를 실행할 때마다 무작위로 생성한 ID 값을 부여한다. 그리고 이 ID 값 중 일부분이 호스트명이 된다. 특정한 컨테이너에 대해 실행할 수 있는 다양한 `docker container` 명령이 있는데, 이때 컨테이너를 특정하려면 컨테이너 ID의 처음 몇글자를 지정하면 된다.

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker container top 9b
UID                 PID                 PPID                C                   STIME               TTY                 TIME                CMD
root                2489                2464                0                   06:39               ?                   00:00:00            /bin/sh
```

`docker container top`은 대상 컨테이너에서 실행중인 프로세스의 목록을 보여준다. 컨테이너에서 실행중인 프로세스가 두 개 이상이라면, 모든 프로세스에 대한 정보가 출력된다. 이는 윈도우 컨테이너도 마찬가지다. 윈도 컨테이너는 항상 백그라운드로 동작하는 프로세스가 더 있기 때문에 이들 모두의 정보가 출력된다.

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker container logs 9b
/ # hostname
9b0083306cbd
/ # date
Sat Dec 27 11:50:00 UTC 2025
```

`docker container logs` 명령은 대상 컨테이너에서 수집된 모든 로그를 출력한다. 도커는 애플리케이션의 표준 출력으로부터 로그를 수집한다. 우리가 조금 전 살펴본 터미널 세션에서는 입력한 명령과 출력된 내용을 모두 볼 수 있었지만, 실제 애플리케이션이 실행된 컨테이너에서는 애플리케이션이 출력하는 로그만 보인다. 예를 들어 어떤 컨테이너에서 모든 GTTP 요청마다 로그를 생성하는 웹 애플리케이션이 동작중이라면, 이 컨테이너는 이들 HTTP 요청에 대한 로그를 출력한다.

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker container inspect 9b
[
    {
        "Id": "9b0083306cbd7cef33c3c19963873441c9a9837827e5088f00ad43d3c04a1920",
        "Created": "2025-12-27T11:48:56.641474875Z",
        "Path": "/bin/sh",
        "Args": [],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 2489,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2025-12-27T11:48:56.864219459Z",
            "FinishedAt": "0001-01-01T00:00:00Z"
        },
        "Image": "sha256:e65ed3e91e579a862befe0d866ffe1e3377d64245c9e9fd82fffaf9e3c961f49",
        "ResolvConfPath": "/var/lib/docker/containers/9b0083306cbd7cef33c3c19963873441c9a9837827e5088f00ad43d3c04a1920/resolv.conf",
        "HostnamePath": "/var/lib/docker/containers/9b0083306cbd7cef33c3c19963873441c9a9837827e5088f00ad43d3c04a1920/hostname",
        "HostsPath": "/var/lib/docker/containers/9b0083306cbd7cef33c3c19963873441c9a9837827e5088f00ad43d3c04a1920/hosts",
        "LogPath": "/var/lib/docker/containers/9b0083306cbd7cef33c3c19963873441c9a9837827e5088f00ad43d3c04a1920/9b0083306cbd7cef33c3c19963873441c9a9837827e5088f00ad43d3c04a1920-json.log",
        "Name": "/sleepy_pascal",
        "RestartCount": 0,
        "Driver": "overlay2",
        "Platform": "linux",
        "MountLabel": "",
        "ProcessLabel": "",
        "AppArmorProfile": "",
        "ExecIDs": null,
        "HostConfig": {
            "Binds": null,
            "ContainerIDFile": "",
            "LogConfig": {
                "Type": "json-file",
                "Config": {}
            },
            "NetworkMode": "default",
            "PortBindings": {},
            "RestartPolicy": {
                "Name": "no",
                "MaximumRetryCount": 0
            },
            "AutoRemove": false,
            "VolumeDriver": "",
            "VolumesFrom": null,
            "CapAdd": null,
            "CapDrop": null,
            "CgroupnsMode": "private",
            "Dns": [],
            "DnsOptions": [],
            "DnsSearch": [],
            "ExtraHosts": null,
            "GroupAdd": null,
            "IpcMode": "private",
            "Cgroup": "",
            "Links": null,
            "OomScoreAdj": 0,
            "PidMode": "",
            "Privileged": false,
            "PublishAllPorts": false,
            "ReadonlyRootfs": false,
            "SecurityOpt": null,
            "UTSMode": "",
            "UsernsMode": "",
            "ShmSize": 67108864,
            "Runtime": "runc",
            "ConsoleSize": [
                0,
                0
            ],
            "Isolation": "",
            "CpuShares": 0,
            "Memory": 0,
            "NanoCpus": 0,
            "CgroupParent": "",
            "BlkioWeight": 0,
            "BlkioWeightDevice": [],
            "BlkioDeviceReadBps": null,
            "BlkioDeviceWriteBps": null,
            "BlkioDeviceReadIOps": null,
            "BlkioDeviceWriteIOps": null,
            "CpuPeriod": 0,
            "CpuQuota": 0,
            "CpuRealtimePeriod": 0,
            "CpuRealtimeRuntime": 0,
            "CpusetCpus": "",
            "CpusetMems": "",
            "Devices": [],
            "DeviceCgroupRules": null,
            "DeviceRequests": null,
            "KernelMemory": 0,
            "KernelMemoryTCP": 0,
            "MemoryReservation": 0,
            "MemorySwap": 0,
            "MemorySwappiness": null,
            "OomKillDisable": null,
            "PidsLimit": null,
            "Ulimits": null,
            "CpuCount": 0,
            "CpuPercent": 0,
            "IOMaximumIOps": 0,
            "IOMaximumBandwidth": 0,
            "MaskedPaths": [
                "/proc/asound",
                "/proc/acpi",
                "/proc/kcore",
                "/proc/keys",
                "/proc/latency_stats",
                "/proc/timer_list",
                "/proc/timer_stats",
                "/proc/sched_debug",
                "/proc/scsi",
                "/sys/firmware"
            ],
            "ReadonlyPaths": [
                "/proc/bus",
                "/proc/fs",
                "/proc/irq",
                "/proc/sys",
                "/proc/sysrq-trigger"
            ]
        },
        "GraphDriver": {
            "Data": {
                "LowerDir": "/var/lib/docker/overlay2/530414c1b3b7193c4170d5e52cb8c6a1fa7cded0a93ed88310f6add46af7f401-init/diff:/var/lib/docker/overlay2/65b9ad1516fa0bfea22f7f003d2f09373a7186592a7c23194376b7bbe30f36eb/diff:/var/lib/docker/overlay2/785a67ad3f57df5f12712eeaf15889fe441601f2f3bc728d054c5f7d944928d9/diff",
                "MergedDir": "/var/lib/docker/overlay2/530414c1b3b7193c4170d5e52cb8c6a1fa7cded0a93ed88310f6add46af7f401/merged",
                "UpperDir": "/var/lib/docker/overlay2/530414c1b3b7193c4170d5e52cb8c6a1fa7cded0a93ed88310f6add46af7f401/diff",
                "WorkDir": "/var/lib/docker/overlay2/530414c1b3b7193c4170d5e52cb8c6a1fa7cded0a93ed88310f6add46af7f401/work"
            },
            "Name": "overlay2"
        },
        "Mounts": [],
        "Config": {
            "Hostname": "9b0083306cbd",
            "Domainname": "",
            "User": "",
            "AttachStdin": true,
            "AttachStdout": true,
            "AttachStderr": true,
            "Tty": true,
            "OpenStdin": true,
            "StdinOnce": true,
            "Env": [
                "PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin"
            ],
            "Cmd": [
                "/bin/sh"
            ],
            "Image": "diamol/base",
            "Volumes": null,
            "WorkingDir": "",
            "Entrypoint": null,
            "OnBuild": null,
            "Labels": {}
        },
        "NetworkSettings": {
            "Bridge": "",
            "SandboxID": "4db2c5908391a8e357597c434ecc8f60c74cac0ef82889e9f232cbf317c61ca9",
            "HairpinMode": false,
            "LinkLocalIPv6Address": "",
            "LinkLocalIPv6PrefixLen": 0,
            "Ports": {},
            "SandboxKey": "/var/run/docker/netns/4db2c5908391",
            "SecondaryIPAddresses": null,
            "SecondaryIPv6Addresses": null,
            "EndpointID": "32493021f8892b0f718dd6f1a5424743a238f7b97576fad5d1291cc53f3366eb",
            "Gateway": "172.17.0.1",
            "GlobalIPv6Address": "",
            "GlobalIPv6PrefixLen": 0,
            "IPAddress": "172.17.0.2",
            "IPPrefixLen": 16,
            "IPv6Gateway": "",
            "MacAddress": "02:42:ac:11:00:02",
            "Networks": {
                "bridge": {
                    "IPAMConfig": null,
                    "Links": null,
                    "Aliases": null,
                    "NetworkID": "7d0fa61a87628418df8917353f5422dafb7ad1b55db3d20ddebe496d838cbf72",
                    "EndpointID": "32493021f8892b0f718dd6f1a5424743a238f7b97576fad5d1291cc53f3366eb",
                    "Gateway": "172.17.0.1",
                    "IPAddress": "172.17.0.2",
                    "IPPrefixLen": 16,
                    "IPv6Gateway": "",
                    "GlobalIPv6Address": "",
                    "GlobalIPv6PrefixLen": 0,
                    "MacAddress": "02:42:ac:11:00:02",
                    "DriverOpts": null
                }
            }
        }
    }
]
hee@yuhuijin-ui-MacBookAir docker-playground % 
```

`docker container inspect` 명령은 대상 컨테이너의 상세한 정보를 보여준다. 컨테이너의 가상 파일 시스템상의 경로, 컨테이너에서 실행중인 명령, 해당 컨테이너가 접속된 가상 도커 네트워크 정보 등 애플리케이션에 발생한 문제를 추적하는데 유용한 정보가 제공된다. 또한, 이 정보는 자동 처리에 유리한 JSON 포맷으로 되어있다.

도커를 사용하는 한 컨테이너는 모두 똑같다. 도커를 적용하면 모든 애플리케이션 위에 관리를 위한 계층이 하나 추가된다. 리눅스 컨텡너에서 동작하는 개발된지 10년이 지난 자바 애플리케이션이나, 윈도 컨테이너에서 동작하는 15년된 닷넷 애플리케이션 등 모두 똑같은 방법으로 관리할 수 있다. `run` 명령으로 애플리케이션을 실행하고, `logs` 명령으로 로그를 출력하고, 프로세스 명령을 보려면 `top` 명령을 실행하며, 컨테이너의 상세 정보를 보고 싶다면 `inspect` 명령을 사용하면 된다.

# 2.4 컨테이너를 사용해 웹 사이트 호스팅하기

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker container ls --all
CONTAINER ID   IMAGE                           COMMAND                 CREATED          STATUS                        PORTS     NAMES
48ea778ae761   diamol/base                     "/bin/sh"               13 minutes ago   Exited (130) 13 minutes ago             infallible_khayyam
9b0083306cbd   diamol/base                     "/bin/sh"               22 hours ago     Up 22 hours                             sleepy_pascal
476c9a32660a   diamol/ch02-hello-diamol        "/bin/sh -c ./cmd.sh"   22 hours ago     Exited (0) 22 hours ago                 gifted_driscoll
91cc19465791   diamol/ch02-hello-diamol        "/bin/sh -c ./cmd.sh"   23 hours ago     Exited (0) 23 hours ago                 sleepy_sinoussi
ab7ea7bfd8f6   moby/buildkit:buildx-stable-1   "buildkitd"             3 weeks ago      Exited (255) 23 hours ago               buildx_buildkit_multiarch-builder0
```

`docker container ls --all` 명령을 실행해 상태와 상관없이 모든 컨테이너의 목록을 확인할 수 있다. 여기서 알아두어야 할 내용은 다음 두 가지다.

1. 컨테이너 내부의 애플리케이션이 실행중이어야 컨테이너의 상태도 실행중이 된다는 점이다. 애플리케이션 프로세스가 종료되면 컨테이너의 상태도 Existed가 된다. 종료된 컨테이너는 CPU 자원이나 메모리를 사용하지 않는다.
2. 컨테이너가 종료돼도 컨테이너는 사라지지 않는다. 종료된 컨테이너는 사라지지 않고 그대로 남아 있다. 나중에 컨테이너를 다시 실행하거나, 로그를 확인하거나, 컨테이너의 파일 시스템에 새로운 파일을 복사하거나 외부로 복사해 올 수 있다. 또한, 컨테이너의 파일 시스템이 그대로 남아 있으므로 호스트 컴퓨터의 디스크 공간을 계속 점유한다.

컨테이너를 실행하고 백그라운드에서 계속 동작하게 하려면 어떻게 하면 될까? 도커를 사용하는 주목적은 웹 사이트, 배치 프로세스, 데이터베이스같은 서버 애플리케이션을 실행하는 것이므로 이러한 형태가 주된 사용 형태일 것이다.

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker container run --detach --publish 8088:80 diamol/ch02-hello
-diamol-web
Unable to find image 'diamol/ch02-hello-diamol-web:latest' locally
latest: Pulling from diamol/ch02-hello-diamol-web
dce8679b510e: Pull complete 
c111552b26df: Pull complete 
ef4263ddbf41: Pull complete 
cac4170335ae: Pull complete 
0a26a833371b: Pull complete 
994988584430: Pull complete 
Digest: sha256:fe5a4c954fe2df5cadeea304ab632533f8ece9e31bd219ea22fdbf8b597571eb
Status: Downloaded newer image for diamol/ch02-hello-diamol-web:latest
784129e52ba7ca1275db5eca4e654faaec2083f2bc81805d0f2cfd67c5b0e3d7
hee@yuhuijin-ui-MacBookAir docker-playground % docker container ls
CONTAINER ID   IMAGE                          COMMAND              CREATED         STATUS         PORTS                  NAMES
784129e52ba7   diamol/ch02-hello-diamol-web   "httpd-foreground"   8 seconds ago   Up 7 seconds   0.0.0.0:8088->80/tcp   agitated_northcutt
```

컨테이너에서 간단한 웹 사이트를 호스팅해보자. 이 명령을 실행하면 컨테이너 ID만 출력된다. 이 컨테이너는 종료되지 않고 백그라운드에서 계속 동작한다. `docker container ls` 명령을 실행해 새로 만든 컨테이너의 상태가 Up인지 확인한다.

컨테이너가 백그라운드에서 동작하면서 네트워크를 주시(listen)하게 하려면 `docker container run` 명령에 아래와 같은 플래그를 적용해야 한다.

- `--detach (-d)`: 컨테이너를 백그라운드에서 실행하며 컨테이너 ID를 출력한다.
- `--publish (-p)`  : 컨테이너의 포트를 호스트 컴퓨터에 공개한다.

`--detach` 플래그를 적용해 실행한 컨테이너는 마치 리눅스 데몬이나 윈도우 서비스처럼 백그라운드로 동작하며 겉으로 드러나지 않는다. 컨테이너의 포트를 호스트 컴퓨터에 공개하는 원리는 좀 더 복잡하다. 도커를 설치하면 호스트 컴퓨터의 네트워크 계층에 도커가 끼어들게 되는데, 그러면 호스트 컴퓨터에서 들고나는 네트워크 트래픽을 모두 도커가 가로채서 그중 필요한 것을 컨테이너에 전달할 수 있다.

**컨테이너는 기본적으로 외부 환경에 노출되지 않는다. 각 컨테이너는 고유의 IP 주소를 갖지만, 이 IP 주소는 도커가 관리하는 내부 가상 네트워크의 주소지 호스트 컴퓨터가 연결된 물리 네트워크에 연결된 것이 아니다.** **컨테이너의 포트를 공개한다는 것은 도커가 호스트 컴퓨터의 포트를 주시하다가 해당 포트로 들어오는 트래픽을 컨테이너로 전달해주는 것이다.** 앞서 본 예제에서는 호스트 컴퓨터의 8080번 포트로 들어온 트래픽이 컨테이너의 80번 포트로 전달됐다.

이 그림에서 나의 컴퓨터는 도커를 실행하는 호스트 컴퓨터가 되고, IP 주소는 192.168.2.150 이다. 이 주소는 내가 사용하는 물리 네트워크의 주소이며 나의 집 공유기가 부여한 것이다. 이 컴퓨터에는 도커를 통해 한 개의 컨테이너가 실행중인데, 이 컨테이너의 IP 주소는 172.0.5.1 이다. 이 주소는 도커가 부여한 도커 가상 네트워크의 주소다. **호스트 컴퓨터가 연결된 물리 네트워크의 컴퓨터는 컨테이너의 IP 주소에 접근할 수 없다. 왜냐하면 이 주소는 도커 내부에만 존재하는 주소이기 때문이다. 그러나 컨테이너의 포트가 공개됐으므로 컨테이너로 트래픽을 전달할 수는 있다.**

브라우저에서 http://localhost:8088 페이지에 접근한다. 이 HTTP 요청은 로컬 컴퓨터에서 보낸 것인데, HTTP 응답은 컨테이너로부터 나온 것이다. 간단한 웹 페이지이지만 도커의 이식성과 효율성을 그대로 누린다. 이 웹 페이지는 웹 서버와 함께 이미지로 패키징된다. 이미지 외에 별도로 필요한 요소는 없다. 웹 개발자는 자신이 작업하는 노트북에서 컨테이너 하나만 실행하면 전체 애플리케이션 스택이 실행된다. 이 점은 운영 팀이 운영 환경에서 여러 물리 서버에 나눠 배치된 100개의 컨테이너를 실행해 전체 애플리케이션을 실행할 때도 마찬가지다.

이 컨테이너의 애플리케이션은 계속 실행된 상태이므로 컨테이너도 계속 실행 상태가 된다.

```c
hee@yuhuijin-ui-MacBookAir docker-playground % docker container stats 78412 
CONTAINER ID   NAME                 CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O    PIDS
784129e52ba7   agitated_northcutt   0.00%     5.398MiB / 7.667GiB   0.07%     3.42kB / 1.79kB   0B / 4.1kB   109
CONTAINER ID   NAME                 CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O    PIDS
784129e52ba7   agitated_northcutt   0.00%     5.398MiB / 7.667GiB   0.07%     3.42kB / 1.79kB   0B / 4.1kB   109
CONTAINER ID   NAME                 CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O    PIDS
784129e52ba7   agitated_northcutt   0.06%     5.398MiB / 7.667GiB   0.07%     3.42kB / 1.79kB   0B / 4.1kB   109
CONTAINER ID   NAME                 CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O    PIDS
784129e52ba7   agitated_northcutt   0.06%     5.398MiB / 7.667GiB   0.07%     3.42kB / 1.79kB   0B / 4.1kB   109
CONTAINER ID   NAME                 CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O    PIDS
784129e52ba7   agitated_northcutt   0.02%     5.398MiB / 7.667GiB   0.07%     3.42kB / 1.79kB   0B / 4.1kB   109
CONTAINER ID   NAME                 CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O    PIDS
784129e52ba7   agitated_northcutt   0.02%     5.398MiB / 7.667GiB   0.07%     3.42kB / 1.79kB   0B / 4.1kB   109
CONTAINER ID   NAME                 CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O    PIDS
784129e52ba7   agitated_northcutt   0.04%     5.398MiB / 7.667GiB   0.07%     3.42kB / 1.79kB   0B / 4.1kB   109
CONTAINER ID   NAME                 CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O    PIDS
784129e52ba7   agitated_northcutt   0.04%     5.398MiB / 7.667GiB   0.07%     3.42kB / 1.79kB   0B / 4.1kB   109
CONTAINER ID   NAME                 CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O    PIDS
784129e52ba7   agitated_northcutt   0.02%     5.398MiB / 7.667GiB   0.07%     3.42kB / 1.79kB   0B / 4.1kB   109
CONTAINER ID   NAME                 CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O    PIDS
784129e52ba7   agitated_northcutt   0.02%     5.398MiB / 7.667GiB   0.07%     3.42kB / 1.79kB   0B / 4.1kB   109
CONTAINER ID   NAME                 CPU %     MEM USAGE / LIMIT     MEM %     NET I/O           BLOCK I/O    PIDS
```

`docker container stats` 명령으로도 실행중인 컨테이너의 상태를 확인할 수 있다. 이 명령을 실행하면 실시간으로 컨테이너의 CPU, 메모리, 네트워크, 디스크 사용량을 볼 수 있다.

컨테이너 사용이 끝나면 `docker container rm` 명령에 컨테이너 ID를 지정해 대상 컨테이너를 삭제할 수 있다. `--force` 플래그를 사용하면 실행중인 컨테이너라도 바로 삭제가 가능하다.

모든 컨테이너를 삭제하려면 다음 명령을 사용한다.

```c
docker container rm --force $(docker container ls --all --quiet)
```

`$()` 문법은 괄호 안 명령의 출력을 다른 명령으로 전달하는 역할을 한다. 이 문법은 리눅스나 맥 터미널은 물론, 윈도 파워셸에서도 그대로 쓸 수 있다. 그러므로 전체 명령의 의미는 호스트 컴퓨터에 존재하는 모든 컨테이너 목록을 만든 다음 이들 컨테이너를 제거하는 것이다. 컨테이너를 한 번에 정리할 수 있는 편리한 명령이지만 사용할 때 주의해야 한다.

# 2.5 도커가 컨테이너를 실행하는 원리

- 도커 엔진(Docker Engine)은 도커의 관리 기능을 맡는 컴포넌트다. **로컬 이미지 캐시를 담당하므로 새로운 이미지가 필요하면 이미지를 내려 받으며, 기존 이미지가 있다면 전에 내려받은 이미지를 사용한다.** 호스트 운영체제와 함께 **컨테이너와 가상 네트워크 등 도커 리소스를 만드는 일도 담당**한다. 도커 엔진은 항시 동작하는 백그라운드 프로세스다. (리눅스 데몬 또는 윈도 서비스와 같다.)
- 도커 엔진은 도커 API를 통해 맡은 기능을 수행한다. 도커 API(Docker API)는 표준 HTTP 기반 REST API다. 도커 엔진의 설정을 수정하면 이 API를 네트워크를 경유해 외부 컴퓨터로부터 호출할 수 없도록 차단(기본 설정)하거나 허용할 수 있다.
    
    [Docker가 REST API를 이용함을 확인해보자](https://senticoding.tistory.com/95)
    
- 도커 명령행 인터페이스(Docker commend-line interface, 도커 CLI)는 도커 API의 클라이언트다. 우리가 `docker` 명령을 사용할 때 실제로 도커 API를 호출하는 것이 바로 Docker CLI다.

도커 엔진과 상호작용할 수 있는 유일한 방법은 API를 통하는 방법뿐이다. 그리고 API의 접근 허용 범위를 몇가지로 선택할 수 있다. CLI는 API에 요청을 전달하는 역할을 한다.

도커 엔진은 `containerd` 라는 컴포넌트를 통해 컨테이너를 실제로 관리하는데, `containerd`는 호스트 운영체제가 제공하는 기능을 통해 컨테이너, 즉 가상 환경을 만든다.

# 2.6 연습 문제: 컨테이너 파일 시스템 다루기

[080258/ch02/lab at main · gilbutITbook/080258](https://github.com/gilbutITbook/080258/tree/main/ch02/lab)

```bash
# docker 컨테이너 안에 있는 폴더의 파일 리스트 확인
hee@yuhuijin-ui-MacBookAir 080258 % docker exec 784 ls /usr/local/apache2/htdocs
index.html

# ch02/lab에 있는 파일을 도커의 파일 시스템 안으로 복사하기
hee@yuhuijin-ui-MacBookAir 080258 % cd ch02/lab
hee@yuhuijin-ui-MacBookAir lab % docker cp index.html 784:/usr/local/apache2/htdocs/index.html
```