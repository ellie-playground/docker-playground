# 6.1 컨테이너 속 데이터가 사라지는 이유

도커 컨테이너에도 단일 드라이브로 된 파일 시스템이 있다. 이 파일 시스템의 내용은 이미지 속 파일로부터 만들어진다. Dockerfile 스크립트에서 `COPY` 인스트럭션을 사용해 파일을 이미지로 복사하면, 이 이미지로 실행한 컨테이너에도 같은 경로에 복사된 파일이 있다. 그리고 앞서 도커 이미지는 여러 개의 레이어 형태로 저장된다고 설명했었다. 컨테이너의 디스크 역시 이 이미지 레이어를 순서대로 합쳐 만든 가상 파일 시스템이다.

모든 컨테이너는 독립된 파일 시스템을 갖는다. 같은 이미지에서 실행한 여러 개의 컨테이너는 처음에는 디스크의 내용이 모두 같지만, 그 중 한 컨테이너에서 애플리케이션이 파일을 수정해도 다른 컨테이너나 이미지는 영향을 받지 않는다.

[docker RW layer / overlay network swarm network](https://velog.io/@agnusdei1207/docker-RW-layer)

```docker
sh-3.2# docker container run --name rn1 diamol/ch06-random-number
Unable to find image 'diamol/ch06-random-number:latest' locally
latest: Pulling from diamol/ch06-random-number
941f399634ec: Already exists 
a9688c0f061a: Pull complete 
353e82f8473e: Pull complete 
d03cc88bf2c6: Pull complete 
Digest: sha256:aea876d5ff413b6e5f2d2bc13f0c70b562e7a2facc215798f22ca5344026e2ce
Status: Downloaded newer image for diamol/ch06-random-number:latest
sh-3.2# docker container run --name rn2 diamol/ch06-random-number
sh-3.2# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
sh-3.2# docker ps -a
CONTAINER ID   IMAGE                       COMMAND                  CREATED          STATUS                      PORTS     NAMES
c87bfc9bb65e   diamol/ch06-random-number   "/bin/sh -c ./random…"   11 seconds ago   Exited (0) 10 seconds ago             rn2
1ed667b764d8   diamol/ch06-random-number   "/bin/sh -c ./random…"   16 seconds ago   Exited (0) 16 seconds ago             rn1
```

컨테이너를 실행하면 텍스트 파일에 무작위 숫자를 쓰는 스크립트가 실행된다. 그리고 컨테이너를 종료하면 Exited 상태가 된다. 이 두 컨테이너는 같은 이미지로부터 실행됐으나 파일 시스템의 내용은 서로 다르다. 2장에서 컨테이너를 종료해도 파일 시스템은 삭제되지 않는다고 배웠다. 그러므로 컨테이너의 파일과 디렉터리는 그대로 남아 있을 것이다.

`docker container cp` 명령을 사용해 컨테이너와 로컬 컴퓨터 간에 파일을 복사할 수 있다. 이 명령에 파일의 경로와 이름을 지정하면 무작위 숫자가 쓰인 텍스트 파일을 로컬 컴퓨터로 복사해 파일의 내용을 확인할 수 있다.

```docker
hee@yuhuijin-ui-MacBookAir practice % docker container cp rn1:/random/number.txt number1.txt
hee@yuhuijin-ui-MacBookAir practice % docker container cp rn2:/random/number.txt number2.txt
hee@yuhuijin-ui-MacBookAir practice % cat number1.txt 
2184
hee@yuhuijin-ui-MacBookAir practice % cat number2.txt
25785
```

두 컨테이너는 모두 같은 경로에 파일을 생성했다. 이 파일을 로컬 컴퓨터로 복사해서 내용을 확인해보니 두 파일의 내용이 서로 달랐다. 이로써 **컨테이너의 파일 시스템이 서로 독립적임을 알 수 있었다.** 여기서는 단지 파일 하나의 내용이지만, 같은 데이터베이스 엔진 이미지로 실행된 두 컨테이너가 서로 전혀 다른 데이터를 담을 수도 있는 것이다.

컨테이너의 파일 시스템은 단일 디스크(리눅스 컨테이너는 /dev/sda1, 윈도는 C:\)다. 그러나 이 디스크는 도커가 여러 출처로부터 합쳐 만들고 컨테이너에 전달한 가상 파일 시스템이다. 이 출처는 기본적으로 이미지 레이어와 컨테이너의 기록 가능 레이어로 구성되는데, 이미지 레이어는 모든 컨테이너가 공유하지만 기록 가능 레이어는 컨테이너마다 다르다.

그림 6-2에서 알 수 있는 두 가지 중요한 사실이 있다. 모든 컨테이너가 공유하는 이미지 레이어는 읽기 전용이고, 각 컨테이너가 따로 갖는 기록 가능 레이어(RW 레이어)는 컨테이너와 같은 생애주기를 갖는다. **이미지 레이어는 이미지를 내려받은 순간부터 삭제할 때까지 로컬 컴퓨터의 이미지 레이어에 존재한다. 그러나 컨테이너의 쓰기 가능 레이어는 컨테이너를 실행할 때 생성되며 컨테이너를 삭제할 때 함께 삭제된다.**(컨테이너를 종료하는 것만으로는 컨테이너가 삭제되지 않는다. 그래서 종료된 컨테이너의 데이터도 그대로 남아있는 것이다.)

기록 가능 레이어를 새 파일을 만드는 데만 사용하는 것은 아니다. 기존 이미지 레이어에 있는 파일을 수정할 수도 있다. 그러나 조금 전에 이미지 레이어는 읽기 전용이라고 하지 않았나? 여기에 바로 비밀이 있다. 도커는 기록중 복사(Copy-On-Write) 라는 방법을 사용해 읽기 전용 레이어의 파일을 수정할 수 있다. 컨테이너에서 이미지 레이어에 포함된 파일을 수정하려 하면, 먼저 도커가 이 파일을 쓰기 가능 레이어로 복사해 온 다음 쓰기 가능 레이어에서 파일을 수정한다.

```docker
sh-3.2# docker container run --name f1 diamol/ch06-file-display
Unable to find image 'diamol/ch06-file-display:latest' locally
latest: Pulling from diamol/ch06-file-display
941f399634ec: Already exists 
716aca3e500c: Already exists 
2755907779b3: Pull complete 
Digest: sha256:98c52776132a793d22524080e16a37db52de6a72dc5687cd5f6ae371d14dad12
Status: Downloaded newer image for diamol/ch06-file-display:latest
https://www.manning.com/books/learn-docker-in-a-month-of-lunches
sh-3.2# echo "http://eltonstoneman.com" > url.txt
sh-3.2# docker container cp url.txt f1:/input.txt
sh-3.2# docker container start --attach f1
http://eltonstoneman.com
```

이번에는 로컬 컴퓨터에서 컨테이너로 파일을 복사했다. 이 파일이 컨테이너가 내용을 출력하는 파일이다. 컨테이너를 재시작해 보면 똑같은 스크립트가 실행되며 파일의 내용을 출력하지만, 파일의 내용이 달라졌다.

컨테이너 속 파일을 수정하면 컨테이너의 동작에 영향을 미친다. 그러나 이미지를 공유하는 다른 컨테이너나 이미지는 영향을 받지 않는다. **수정된 파일은 해당 컨테이너의 기록 가능 레이어에만 존재하기 때문이다.** 새로운 컨테이너는 이미지로부터 받은 최초의 내용을 담은 파일 시스템을 가지며, f1 컨테이너가 삭제되면 수정된 파일도 사라진다.

```docker
hee@yuhuijin-ui-MacBookAir docker-playground % docker container run --name f2 diamol/ch06-file-display
https://www.manning.com/books/learn-docker-in-a-month-of-lunches
hee@yuhuijin-ui-MacBookAir docker-playground % docker container rm -f f1
f1
hee@yuhuijin-ui-MacBookAir docker-playground % docker container cp f1:/input.txt .
Error: No such container:path: f1:/input.txt
```

새로 실행한 컨테이너는 이미지로부터 받은 원래 내용의 파일을 사용하며, 처음 만든 컨테이너를 삭제하면 그 파일 시스템과 함께 수정된 파일도 사라진다.

컨테이너 파일 시스템은 컨테이너와 같은 생애주기를 갖는다. 컨테이너가 삭제되면 이 컨테이너의 기록 가능 레이어와 여기서 수정된 데이터도 함께 삭제된다. 도커를 사용하면 컨테이너 삭제를 밥 먹듯이 하게 된다. 실무에서는 새 이미지를 빌드하고 오래된 컨테이너를 삭제한 다음 새 이미지에서 실행한 컨테이너로 대체하는 방법으로 애플리케이션을 업데이트한다. 이 과정에서 기존 컨테이너에 있는 수정된 데이터는 모두 손실된다. 새 컨테이너는 이미지에서 받은 파일만 갖고 있기 때문이다.

애플리케이션이 계산 비용이 큰 계산 결과처럼 몇 가지 일시적 데이터를 캐싱만 하는 경우라면 새 컨테이너가 빈 캐시를 갖고 시작하더라도 문제가 없다. 하지만 그렇지 않은 경우라면 아마 재앙이 일어날 것이다. 컨테이너로 데이터베이스를 실행해 사용했는 데이터베이스 버전을 업데이트했더니 모든 데이터가 사라졌다고 생각해보자.

도커는 이런 상황도 감안해 만들어졌다. 컨테이너의 가상 파일 시스템은 여전히 이미지 레이어와 기록 가능 레이어로 구성되지만, 몇 가지 추가할 수 있는 요소가 더 있다. 도커 볼륨(Docker volume)과 마운트(mount)다. 이들 요소는 컨테이너와는 별개의 생애주기를 갖기 때문에 컨테이너가 대체돼도 지속돼야 할 데이터를 저장할 수 있다.

# 6.2 도커 볼륨을 사용하는 컨테이너 실행하기

도커 볼륨은 도커에서 스토리지를 다루는 단위다. 볼륨은 컨테이너와 독립적으로 존재하며 별도의 생애주기를 갖지만, 컨테이너에 연결할 수 있다. 볼륨을 생성해 애플리케이션 컨테이너에 연결하면 컨테이너 파일 시스템의 한 디렉터리가 된다. 나중에 애플리케이션을 업데이트하더라도 새로운 컨테이너에 다시 볼륨을 연결하면 데이터가 그대로 유지된다.

컨테이너가 볼륨을 사용하는 방법은 두가지다. 첫 번째는 수동으로 직접 볼륨을 생성해 컨테이너에 연결하는 방법이고, 두 번째는 Dockerfile 스크립트에서 `VOLUME` 인스트럭션을 사용하는 방법이다. 이 인스트럭션을 사용해 만든 이미지로 컨테이너를 실행하면 자동으로 볼륨을 생성한다. `VOLUME` 인스트럭션의 문법은 `VOLUME <target-directory>` 형식이다.

```docker
FROM diamol/dotnet-aspnet
WORKDIR /app
ENTRYPOINT ["dotnet", "ToDoList.dll"]

VOLUME /data
COPY --from=builder /out/ .
```

이 이미지로부터 컨테이너를 실행하면 자동으로 볼륨을 생성해 컨테이너에 연결해준다. 실행된 컨테이너에는 /data 디렉터리가 있는데, 이 디렉터리는 다른 디렉터리와 똑같이 사용할 수 있지만 이 디렉터리의 내용은 볼륨에 영구적으로 저장된다.

```docker
hee@yuhuijin-ui-MacBookAir todo-list % docker container run --name todo1 -d -p 8010:80 diamol/ch06-todo-list
Unable to find image 'diamol/ch06-todo-list:latest' locally
latest: Pulling from diamol/ch06-todo-list
f338bc35613f: Pull complete 
5636d912c69e: Pull complete 
362df8b85fca: Pull complete 
24c3992ceef4: Pull complete 
546a81dfea0f: Pull complete 
3e6d6e6fdcce: Pull complete 
697b28c7a381: Pull complete 
Digest: sha256:a7367ad4c81543d21f2b131a98c8e4c4fb75abe67df5d66ccdf34e0bd34f9b9a
Status: Downloaded newer image for diamol/ch06-todo-list:latest
ce1c0bf1dec3998a2061e1ee9012e9e190aaf6c66e56b178f8f846bf6b53fc3f
# Docker 컨테이너의 볼륨 정보 확인하기
hee@yuhuijin-ui-MacBookAir todo-list % docker container inspect --format '{{.Mounts}}' todo1
[{volume 975c02c3bfd523e9991ff06cf5b182126bfa3e5d31ec923230d243b5a657d5eb /var/lib/docker/volumes/975c02c3bfd523e9991ff06cf5b182126bfa3e5d31ec923230d243b5a657d5eb/_data /data local  true }]
hee@yuhuijin-ui-MacBookAir todo-list % docker volume ls
DRIVER    VOLUME NAME
local     975c02c3bfd523e9991ff06cf5b182126bfa3e5d31ec923230d243b5a657d5eb
```

컨테이너에서 동작하는 애플리케이션에서는 볼륨의 존재를 전혀 느낄 수 없다. 웹 브라우저에서 접근해보면 to-do 애플리케이션의 화면을 볼 수 있다. 이 애플리케이션은 데이터를 /data 디렉터리에 저장하는데, 웹 페이지에서 ‘할 일’을 하나 추가하면 도커 볼륨에 저장된다.

도커 이미지에 볼륨을 정의하면 컨테이너를 생성할 때마다 새로운 볼륨을 만든다. 하지만 컨테이너가 같은 볼륨을 공유하게 할 수도 있다. to-do 애플리케이션의 새로운 컨테이너를 그냥 실행하면 자신만의 볼륨을 생성하니 할일 목록이 비어있다. 그러나 `volumes-from` 플래그를 적용하면 다른 컨테이너의 볼륨을 연결할 수 있다.

```docker
hee@yuhuijin-ui-MacBookAir todo-list % docker container run --name todo2 -d diamol/ch06-todo-list
e1cb66025eb0cb36a23318d2087dae6ad785d69055f99f6e4078d370931277e7
hee@yuhuijin-ui-MacBookAir todo-list % docker container exec todo2 ls /data
hee@yuhuijin-ui-MacBookAir todo-list % docker container run -d --name t2 --volumes-from todo1 diamol/ch06-todo-l
ist
8c0a57dfcc0b15e37846aec8fded91256a73ae6778ee881eb4b8479f9ad9b477
hee@yuhuijin-ui-MacBookAir todo-list % docker container exec t2 ls /data
todo-list.db
```

두번째 컨테이너는 새로운 볼륨을 생성해 연결하기 때문에 /data 디렉터리가 비어있지만, 세 번째 컨테이너는 첫번째 컨테이너와 볼륨을 공유하므로 애플리케이션의 데이터를 세 번째 컨테이너의 디렉터리에서도 볼 수 있다.

컨테이너 간 볼륨 공유는 이해하긴 쉬워도 모든 일을 해결해 주지는 못한다. 애플리케이션 컨테이너는 종종 자신만이 접근할 수 있는 파일을 필요로 한다. 이러한 파일을 다른 컨테이너가 동시에 접근하게 허용하면 애플리케이션이 비정상적으로 동작할 수도 있다. 볼륨은 컨테이너 간 파일 공유보다는 업데이트 간 상태를 보존하기 위한 용도로 사용해야 하며, 이미지에서 정의하는 것보다는 명시적으로 관리하는 편이 더 낫다. 볼륨에 이름을 붙여 생성하고 업데이트 시 다른 컨테이너로 옮겨 연결하면 된다.

```docker
ee@yuhuijin-ui-MacBookAir todo-list % target='/data'
hee@yuhuijin-ui-MacBookAir todo-list % docker volume create todo-list
todo-list
hee@yuhuijin-ui-MacBookAir todo-list % docker container run -d -p 8011:80 -v todo-list:$target --name todo-v1 di
amol/ch06-todo-list
b509bc3a37e9ff065ebe236a4f364239413eb6418d47bf801d3ec5221cd37d7e
hee@yuhuijin-ui-MacBookAir todo-list % docker container rm -f todo-v1
todo-v1
hee@yuhuijin-ui-MacBookAir todo-list % docker container run -d -p 8011:80 -v todo-list:$target --name todo-v2 diamol/ch06-todo-list:v2
Unable to find image 'diamol/ch06-todo-list:v2' locally
v2: Pulling from diamol/ch06-todo-list
f338bc35613f: Already exists 
5636d912c69e: Already exists 
362df8b85fca: Already exists 
24c3992ceef4: Already exists 
546a81dfea0f: Already exists 
a70264aae6a4: Pull complete 
5b7dcfc5b742: Pull complete 
182e1a5c3e0e: Pull complete 
Digest: sha256:d2341450aaf2c48ed48e8607bd2271e5b89d38779487c746836d42ddafa5496c
Status: Downloaded newer image for diamol/ch06-todo-list:v2
4b8c6c8ada66a57213546ee1316d89c387a030594d6a07efe3928bebc9094934
```

<img width="1804" height="1134" alt="image" src="https://github.com/user-attachments/assets/1e039fe5-7217-424c-a1fd-b984f9f4b3ff" />


볼륨은 컨테이너보다 먼저 생성돼 자신과 연결됐던 컨테이너가 삭제된 뒤에도 그대로 남아 있다. 이로써 볼륨이 컨테이너와 별개의 생애주기를 가졌다는 것을 알 수 있다. 볼륨을 사용하면 컨테이너를 교체해 애플리케이션을 업데이트 하더라도 이렇게 데이터를 그대로 보존할 수 있다.

Dockerfile 스크립트의 `VOLUME` 인스트럭션과 `docker container` 명령의 `--volume` 플래그는 별개 기능이다. **`VOLUME` 인스트럭션을 사용해 빌드된 이미지로 `docker container run` 명령에서 볼륨을 지정하지 않으면 항상 새로운 볼륨을 함께 생성한다.** 이 볼륨은 무작위로 만들어진 식별자를 가지므로, 컨테이너를 삭제한 후 볼륨을 재사용하려면 이 식별자를 미리 기억해야 한다.

반면 **`--volume` 플래그는 이미지에 볼륨이 정의돼 있든 말든 지정된 볼륨을 컨테이너에 마운트한다.** 이미지에 볼륨이 정의돼 있더라도 이 정의가 무시되므로 새로운 볼륨이 생성되지 않는다. 지금 우리가 todo 애플리케이션을 업데이트한 과정이 바로 이 경우다.

이미지에 볼륨이 정의돼 있지 않아도 똑같은 결과를 얻는다. 이미지를 만드는 입장에서는 안전장치 삼아 `VOLUME` 인스트럭션을 이미지 정의에 포함시켜 두는 것이 좋다. 그러면 사용자가 볼륨을 지정하지 않더라도 데이터를 유실할 일이 없다. 하지만 역시 사용자 입장에서 보면, 이미지의 기본 볼륨 설정에 의존하지 말고 별도로 이름을 붙여 만든 볼륨을 사용하는 것이 좋다.

# 6.3 파일 시스템 마운트를 사용하는 컨테이너 실행하기

볼륨의 장점은 컨테이너와 스토리지의 생애주기를 분리하면서도 도커를 사용하는 방식 그대로 스토리지를 다룰 수 있는 점이다. 볼륨 역시 호스트 컴퓨터상에 존재하지만 컨테이너와는 분리돼 있기 때문이다. 하지만 호스트의 스토리지를 컨테이너에 좀 더 직접적으로 연결할 수 있는 수단이 있다. 바로 바인드 마운트(bind mount)다. **바인드 마운트는 호스트 컴퓨터 파일 시스템의 디렉터리를 컨테이너 파일 시스템의 디렉터리로 만든다.** 바인드 마운트도 볼륨과 마찬가지로 컨테이너의 입장에서는 그냥 평범한 디렉터리에 불과하다. 그러나 도커를 사용하는 입장에서는 컨테이너가 호스트 컴퓨터의 파일에 직접 접근할 수 있고 그 반대도 가능해지므로 좀 더 흥미로운 일을 할 수 있다.

바인드 마운트를 사용하면 호스트 컴퓨터의 파일 시스템을 명시적으로 지정해 컨테이너 데이터로 쓸 수 있다. 속도 면에서 뛰어난 SSD 디스크, 고사용성 디스크 어레이, 네트워크 상에서 사용하는 분산 스토리지까지 호스트 컴퓨터에서 접근 가능한 파일 시스템이라면 무엇이든 컨테이너에서도 사용할 수 있다. 만약 RAID가 적용된 디스크 어레이를 가진 서버가 있다면, 이 스토리지를 to-do 앱의 데이터베이스를 저장할 고신뢰성 스토리지로 활용할 수도 있다.

```docker
hee@yuhuijin-ui-MacBookAir practice % source="$(pwd)/databases" && target='/data' 
hee@yuhuijin-ui-MacBookAir practice % mkdir ./databases
hee@yuhuijin-ui-MacBookAir practice % docker container run --mount type=bind,source=$source,target=$target -d -p 8012:80 diamol/ch06-todo-list
Unable to find image 'diamol/ch06-todo-list:latest' locally
latest: Pulling from diamol/ch06-todo-list
f338bc35613f: Pull complete 
5636d912c69e: Pull complete 
362df8b85fca: Pull complete 
24c3992ceef4: Pull complete 
546a81dfea0f: Pull complete 
3e6d6e6fdcce: Pull complete 
697b28c7a381: Pull complete 
Digest: sha256:a7367ad4c81543d21f2b131a98c8e4c4fb75abe67df5d66ccdf34e0bd34f9b9a
Status: Downloaded newer image for diamol/ch06-todo-list:latest
e7d46b2c46a92ed1023646494474f224cc90df58df2b43d3d0686dfe685eaf9d
hee@yuhuijin-ui-MacBookAir practice % curl http://localhost:8012

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DIAMOL To-Do List</title>
    <base href="/" />
    <link rel="stylesheet" href="css/bootstrap/bootstrap.min.css" />
    <link href="css/site.css" rel="stylesheet" />
</head>
<body>
    <app>
        <!--Blazor:{"sequence":0,"type":"server","prerenderId":"e4739d47454747ae8919458211e8cfd8","descriptor":"CfDJ8ApCIVDS8phOvEReCePHWCtkQ1hvBuXUqdTuQu10aLff4MGBd9ceAYd9ZLnNTy6N99Id-uCSMhCAHdC69RVxfTYx236PX_e7LThcpxUPQvrFeO08UTrjr6StA34A_6NIe_IZV8rrg5I3sbMxLB5l4YKw5nSGpHTjRn0cWMOM0OZgdSCYbmNtaiasXi5BltcoAItqG_nihmSMA9_izisb79QXVcEOWSb_6uvomuyHFL9U0eTOJdqdpsUPQjROLs2boihQosm7IM_sHrW7aYYJIDHrnpqaKNMVd15Y_lW8SR_b"}-->
        <div class="sidebar">
    <div class="top-row pl-4 navbar navbar-dark">
    <a class="navbar-brand" href>DIAMOL To-Do List</a>
    <button class="navbar-toggler">
        <span class="navbar-toggler-icon"></span>
    </button>
</div>

<div class="collapse">
    <ul class="nav flex-column">
        <li class="nav-item px-3">
            <a href="" class="nav-link active">
                <span class="oi oi-home" aria-hidden="true"></span> Home
            </a>
        </li>
        <li class="nav-item px-3">
            <a href="new" class="nav-link">
                <span class="oi oi-plus" aria-hidden="true"></span> New item
            </a>
        </li>
        <li class="nav-item px-3">
            <a href="list" class="nav-link">
                <span class="oi oi-list-rich" aria-hidden="true"></span> To-do list
            </a>
        </li>
        <li class="nav-item px-3">
            <a href="diagnostics" class="nav-link">
                <span class="oi oi-cog" aria-hidden="true"></span> Diagnostics
            </a>
        </li>
    </ul>
</div>
</div>

<div class="main">
    <div class="top-row px-4">
        <a href="https://github.com/sixeyed/diamol/tree/master/ch06/exercises/todo-list" target="_blank">Source Code</a>
    </div>

    <div class="content px-4">
        <h1>Welcome to the TODO list</h1>

<p>You have 0 items to do. </p>

<p><a href="/list">See the list</a> or <a href="/new">add a new item</a>.</p>
    </div>
</div>
    <!--Blazor:{"prerenderId":"e4739d47454747ae8919458211e8cfd8"}-->
    </app>

    <script src="_framework/blazor.server.js"></script>
</body>
</html>
hee@yuhuijin-ui-MacBookAir practice % ls ./databases
todo-list.db
hee@yuhuijin-ui-MacBookAir practice % 
```

바인드 마운트는 양방향으로 동작한다. 컨테이너에서 만든 파일을 호스트 컴퓨터에서 수정할 수도 있고, 반대로 호스트에서 만든 파일도 컨테이너에서 수정할 수 있다. 호스트 컴퓨터에 대한 공격을 방지하기 위해 컨테이너는 대개 최소 권한을 가진 계정으로 실행되는데, 바인드 마운트를 사용하면 호스트 컴퓨터 파일에 접근하기 위해 권한 상승이 필요하다. 그래서 Dockerfile 스크립트에서 `USER` 인스트럭션을 사용해 컨테이너에 관리자 권한을 부여한다. (리눅스는 root, 윈도는 ContainerAdministrator 계정으로 실행된다)

파일에 쓰기 작업을 할 필요가 없다면 호스트 컴퓨터의 디렉터리를 읽기 전용으로 컨테이너에 연결할 수도 있다. 이 방법은 호스트 컴퓨터에 작성한 설정을 컨테이너에 적용하기 위해 자주 쓰인다. to-do 애플리케이션은 이미지 내에 로그 출력을 최소한으로 줄이도록 설정된 설정 파일을 내장하고 있는데, 이 방법으로 이미지를 수정하지 않고도 애플리케이션의 설정을 변경할 수 있다.

```docker
hee@yuhuijin-ui-MacBookAir practice % source="$(pwd)/config" && target='/app/config'                                             
hee@yuhuijin-ui-MacBookAir practice % docker container run --name todo-configured -d -p 8013:80 --mount type=bind,source=$source,target=$target,readonly di
amol/ch06-todo-list
docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /host_mnt/Users/hee/Desktop/repository/docker-playground/도커 교과서/practice/config.
See 'docker run --help'.
hee@yuhuijin-ui-MacBookAir practice % mkdir config
hee@yuhuijin-ui-MacBookAir practice % docker container run --name todo-configured -d -p 8013:80 --mount type=bind,source=$source,target=$target,readonly diamol/ch06-todo-list
cab77069ab03344d6623a46e5a5a2708ad976840e3ece3c23af93f377b83277d
hee@yuhuijin-ui-MacBookAir practice % curl http://localhost:8013                    

<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>DIAMOL To-Do List</title>
    <base href="/" />
    <link rel="stylesheet" href="css/bootstrap/bootstrap.min.css" />
    <link href="css/site.css" rel="stylesheet" />
</head>
<body>
    <app>
        <!--Blazor:{"sequence":0,"type":"server","prerenderId":"e7d301d275ab42afa37fd3bf9b93f461","descriptor":"CfDJ8LVjPlsF_M1HnpC3sWuPZSVVTRWM1-LihRdbRVjvn9Tl9nTbvXK9tPsQJbOd1azZPv71bjvwugajc5TEoP0Cbe9QeIF5g_IMxvnFaikWHOWkelMGqBegtTEf0ecSNEaE4a1y-jeaBy6rh-HCxtQcx_SS8fjQo3lVWOokWLwpeAKqzQvtw3alDFi2sYii3mDRqqNjEkufE7RcN0fMAsCWqUt6BRKcH3C0F0e3fIQJskMkU9Sim7rdv_BSwfVB7_HSv2UemsgIzAAXMRgeoNCE9xg6Al6EWLLeB05am1OOQ0Ch"}-->
        <div class="sidebar">
    <div class="top-row pl-4 navbar navbar-dark">
    <a class="navbar-brand" href>DIAMOL To-Do List</a>
    <button class="navbar-toggler">
        <span class="navbar-toggler-icon"></span>
    </button>
</div>

<div class="collapse">
    <ul class="nav flex-column">
        <li class="nav-item px-3">
            <a href="" class="nav-link active">
                <span class="oi oi-home" aria-hidden="true"></span> Home
            </a>
        </li>
        <li class="nav-item px-3">
            <a href="new" class="nav-link">
                <span class="oi oi-plus" aria-hidden="true"></span> New item
            </a>
        </li>
        <li class="nav-item px-3">
            <a href="list" class="nav-link">
                <span class="oi oi-list-rich" aria-hidden="true"></span> To-do list
            </a>
        </li>
        <li class="nav-item px-3">
            <a href="diagnostics" class="nav-link">
                <span class="oi oi-cog" aria-hidden="true"></span> Diagnostics
            </a>
        </li>
    </ul>
</div>
</div>

<div class="main">
    <div class="top-row px-4">
        <a href="https://github.com/sixeyed/diamol/tree/master/ch06/exercises/todo-list" target="_blank">Source Code</a>
    </div>

    <div class="content px-4">
        <h1>Welcome to the TODO list</h1>

<p>You have 0 items to do. </p>

<p><a href="/list">See the list</a> or <a href="/new">add a new item</a>.</p>
    </div>
</div>
    <!--Blazor:{"prerenderId":"e7d301d275ab42afa37fd3bf9b93f461"}-->
    </app>

    <script src="_framework/blazor.server.js"></script>
</body>
</html>
hee@yuhuijin-ui-MacBookAir practice % docker container logs todo-configured
warn: Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository[60]
      Storing keys in a directory '/root/.aspnet/DataProtection-Keys' that may not be persisted outside of the container. Protected data will be unavailable when container is destroyed.
warn: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[35]
      No XML encryptor configured. Key {5b3e63b5-fc05-47cd-9e90-b7b16b8f6525} may be persisted to storage in unencrypted form.
info: Microsoft.Hosting.Lifetime[0]
      Now listening on: http://[::]:80
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Production
info: Microsoft.Hosting.Lifetime[0]
      Content root path: /app
```

호스트 컴퓨터에 위치한 설정 파일에는 좀 더 상세한 내용까지 로그를 출력하도록 설정돼 있다. 컨테이너를 실행하면 호스트와 컨테이너의 디렉터리가 연결되고 애플리케이션이 설정 파일 디렉터리를 발견해 안에 있는 로그 설정을 읽어 들인다.

호스트 컴퓨터가 접근할 수 있는 스토리지라면 무엇이든 바인드 마운트를 통해 컨테이너에 연결할 수 있다. 예를 들어 네트워크 드라이브가 경로 /mnt/nfs(리눅스)나 X:드라이브(윈도)에 연결돼 있다면 이 네트워크 드라이브를 바인드 마운트로 컨테이너에 연결할 수 있는 것이다. 이런 방법으로 분산 스토리지를 컨테이너에 연결해 유상태 애플리케이션에서 사용하게 하면 신뢰성을 크게 개선할 수 있지만, 한계도 존재한다.

# 6.4 파일 시스템 마운트의 한계점

컨테이너의 마운트 대상 디렉터리가 이미 존재하고 이미지 레이어에 이 디렉터리의 파일이 포함돼 있다면 어떻게 될까? 지금까지 본 경우를 생각하면 원래 있던 파일과 마운트된 파일에 모두 접근 가능하지 않을까? 하지만 이번에는 틀렸다. **이미 존재하는 대상 디렉터리에 마운트하면 마운트의 원본 디렉터리가 기존 디렉터리를 완전히 대체**한다. 그래서 이미지에 포함돼 있던 원래 파일은 사용할 수 없다.

```docker
hee@yuhuijin-ui-MacBookAir practice % source="$(pwd)/new" && target='/init'      
hee@yuhuijin-ui-MacBookAir practice % docker container run diamol/ch06-bind-mount
Unable to find image 'diamol/ch06-bind-mount:latest' locally
latest: Pulling from diamol/ch06-bind-mount
941f399634ec: Pull complete 
716aca3e500c: Pull complete 
9f6eb4301517: Pull complete 
b04299465958: Pull complete 
4a680457f2b1: Pull complete 
Digest: sha256:ec0b831d29ed820ad5b2a333b21d63cf6aec13a9808e9d5bd13d6714924f568d
Status: Downloaded newer image for diamol/ch06-bind-mount:latest
abc.txt
def.txt
hee@yuhuijin-ui-MacBookAir practice % docker container run --mount type=bind,source=$source,target=$target diamol/ch06-bind-mount
docker: Error response from daemon: invalid mount config for type "bind": bind source path does not exist: /host_mnt/Users/hee/Desktop/repository/docker-playground/도커 교과서/practice/new.
See 'docker run --help'.
hee@yuhuijin-ui-MacBookAir practice % mkdir new
hee@yuhuijin-ui-MacBookAir practice % docker container run --mount type=bind,source=$source,target=$target diamol/ch06-bind-mount
hee@yuhuijin-ui-MacBookAir practice % 
```

처음 실행한 컨테이너는 두 개의 파일명 abc.txt와 def.txt를 출력했다. 이들 파일은 이미지 레이어에서 컨테이너로 전달된 파일이다. 두 번째 컨테이너는 이미지 레이어에서 받은 파일이 마운트된 파일로 대체됐으므로 파일 목록이 123.txt와 456.txt로 바뀌었다.

호스트 컴퓨터의 **파일 하나**를 컨테이너에 이미 존재하는 **디렉터리**로 마운트하면 어떻게 될까? 이번에는 **디렉터리의 파일이 합쳐져 이미지에서 온 파일과 호스트에서 마운트된 파일이 모두 나타난다.** 단, 윈도 컨테이너는 이 기능을 제공하지 않아 동작이 달라진다. → **파일 하나를 마운트하면 합쳐지고, 디렉터리를 마운트하면 덮어쓴다.**

**디렉터리를 마운트하면** → 호스트 디렉터리가 컨테이너 디렉터리를 완전히 덮어씁니다. 기존 컨테이너 파일은 가려져서(masked) 보이지 않게 됩니다.

**단일 파일을 마운트하면** → 이 경우에만 "합쳐지는" 효과가 발생합니다. 해당 파일만 호스트 파일로 대체되고, 디렉터리 내 나머지 파일들은 그대로 유지됩니다.

```bash
# 디렉터리 마운트 → 기존 파일 전부 가려짐
docker run -v /host/dir:/container/dir myimage

# 단일 파일 마운트 → 나머지 파일은 유지
docker run -v /host/my.conf:/container/dir/my.conf myimage
```

두 가지 경우가 있어요:

- **같은 이름의 파일이 이미 존재하면** → 호스트 파일로 **덮어씁니다**
- **같은 이름의 파일이 없으면** → 해당 파일이 디렉터리에 **추가됩니다**

어느 경우든 디렉터리 내 **나머지 기존 파일들은 그대로 유지**되는 게 핵심이에요. 디렉터리 마운트와 달리 전체를 가리지 않으니까요.

```bash
# 컨테이너의 /etc/nginx/conf.d/ 에 default.conf, extra.conf가 있다고 가정

# default.conf를 마운트 → 호스트 파일로 덮어쓰고, extra.conf는 그대로
docker run -v /host/default.conf:/etc/nginx/conf.d/default.conf myimage

# custom.conf를 마운트 → 새로 추가되고, 기존 파일들도 그대로
docker run -v /host/custom.conf:/etc/nginx/conf.d/custom.conf myimage
```

컨테이너 파일 시스템은 윈도 컨테이너와 리눅스 컨테이너의 동작이 일치하지 않는 몇 안되는 영역 중 하나다. 동일하게 동작하는 경우가 없는 것은 아니다. 예를 들면 Dockerfile 스크립트 내 경로 문자열이 그렇다. Dockerfile 스크립트에서 리눅스 스타일의 경로 문자열 \data를 사용해도 윈도 컨테이너에서 그대로 C:\data의 별명으로 처리된다. 그러나 볼륨이나 바인드 마운트에서는 동작이 달라진다.

```docker
hee@yuhuijin-ui-MacBookAir practice % docker container run --mount type=bind,source="$(pwd)/new/123.txt",target=/init/123.txt diamol/ch06-bind-mount
123.txt     # 추가된 파일
abc.txt
def.txt
```

리눅스 환경에서는 우리가 배운대로 동작하는 반면, 윈도는 반드시 디렉토리만 마운트해야한다는 오류가 발생한다.

분산 파일 시스템을 컨테이너에 바인드 마운트하면 어떻게 될까? 이 경우에도 컨테이너에서 실행되는 애플리케이션이 정상적으로 동작할까? 분산 파일 시스템을 사용하면 네트워크 상의 모든 컴퓨터에서 데이터에 접근할 수 있지만, 대개 분산 파일 시스템의 메커니즘은 윈도 파일 공유에 쓰이는 SMB, 애저 파일스, AWS S3 등 로컬 컴퓨터 운영체제의 파일 시스템과 다른 경우가 많다. 이러한 분산 파일 스토리지를 컨테이너에 마운트하면 일반적인 파일 시스템의 일부처럼 보이기는 하겠지만 지원하지 않는 동작이 있을 수 있다.

바인드 마운트의 원본 스토리지가 컨테이너에서 사용하는 모든 파일 시스템 기능을 제공하지 않을 수 있다. 컨테이너에 분산 스토리지를 마운트할 계획이라면, 이런 위험과 함께 분산 스토리지의 성능이 로컬 스토리지와 큰 차이가 있다는 것도 고려해야 한다. 디스크를 많이 사용하는 애플리케이션을 분산 스토리지를 마운트한 컨테이너에서 실행한다면 모든 파일 입출력이 네트워크를 거쳐야 하는 만큼 최악의 경우 애플리케이션이 멈춰버릴 가능성도 있다.

# 6.5 컨테이너의 파일 시스템은 어떻게 만들어지는가?

모든 컨테이너는 도커가 다양한 출처로부터 모아 만든 단일 가상 디스크로 구성된 파일 시스템을 갖는다. 이 파일 시스템을 유니언 파일 시스템(Union File System)이라고 한다.

컨테이너는 유니언 파일 시스템을 통해 물리적 위치가 서로 다른 파일과 디렉터리에 마치 단일 디스크를 사용하듯 접근할 수 있다.

컨테이너에서 실행되는 애플리케이션의 입장에서는 단일 디스크만을 볼 수 있지만, 컨테이너나 이미지를 생성해 사용하는 사용자는 여러 출처를 합쳐 이 디스크를 구성할 수 있다. 여러 개의 이미지 레이어, 역시 하나 이상의 볼륨 마운트와 바인드 마운트를 컨테이너에 연결할 수 있다. 그러나 기록 가능 레이어는 하나밖에 가질 수 없다.

- 기록 가능 레이어: 비용이 비싼 계산이나 네트워크를 통해 저장해야 하는 데이터의 캐싱 등 단기 저장에 적합하다. 각 컨테이너마다 독립적인 기록 가능 레이어를 갖지만, 컨테이너가 삭제되면 여기 저장된 데이터는 유실된다.
- 로컬 바인드 마운트: 호스트 컴퓨터와 컨테이너 간 데이터를 공유하기 위해 사용한다. 개발자의 로컬 컴퓨터에서 컨테이너로 소스 코드를 전달하기 위해 사용하면 로컬 컴퓨터에서 수정한 내용이 이미지 빌드 없이도 즉시 컨테이너로 전달될 수 있다.
- 분산 바인드 마운트: 네트워크 스토리지와 컨테이너 간에 데이터를 공유하기 위해 사용한다. 가용성이 높지만 로컬 디스크와 비교해 지원하지 않는 파일 시스템 기능이 있거나 성능 면에서 차이가 있을 수 있다. 읽기 전용으로 설정 파일을 전달하거나 공유 캐시로 활용할 수 있으며 읽기 쓰기 가능으로 데이터를 저장해 동일 네트워크 상의 모든 컨테이너나 컴퓨터와 데이터를 공유하는데 적합하다.
- 볼륨 마운트: 컨테이너와 도커 객체인 볼륨 간에 데이터를 공유하기 위해 사용된다. 볼륨 마운트를 사용하면 애플리케이션이 볼륨에 데이터를 영구적으로 저장한다. 컨테이너를 교체하는 방식으로 애플리케이션을 업데이트해도, 이전 버전 컨테이너의 데이터를 그대로 유지할 수 있다.
- 이미지 레이어: 이미지 레이어는 컨테이너의 초기 파일 시스템을 구성한다. 레이어는 적층 구조를 갖는데, 후속 레이어와 이전 레이어의 내용이 서로 충돌하는 경우 후속 레이어의 내용이 적용된다. 레이어는 읽기 전용이며 여러 컨테이너가 공유한다.