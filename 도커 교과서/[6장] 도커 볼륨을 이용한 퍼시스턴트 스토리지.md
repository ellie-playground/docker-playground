# 6.1 컨테이너 속 데이터가 사라지는 이유

도커 컨테이너에도 단일 드라이브로 된 파일 시스템이 있다. 이 파일 시스템의 내용은 이미지 속 파일로부터 만들어진다. Dockerfile 스크립트에서 `COPY` 인스트럭션을 사용해 파일을 이미지로 복사하면, 이 이미지로 실행한 컨테이너에도 같은 경로에 복사된 파일이 있다. 그리고 앞서 도커 이미지는 여러 개의 레이어 형태로 저장된다고 설명했었다. 컨테이너의 디스크 역시 이 이미지 레이어를 순서대로 합쳐 만든 가상 파일 시스템이다.

모든 컨테이너는 독립된 파일 시스템을 갖는다. 같은 이미지에서 실행한 여러 개의 컨테이너는 처음에는 디스크의 내용이 모두 같지만, 그 중 한 컨테이너에서 애플리케이션이 파일을 수정해도 다른 컨테이너나 이미지는 영향을 받지 않는다.

[docker RW layer / overlay network swarm network](https://velog.io/@agnusdei1207/docker-RW-layer)

```docker
sh-3.2# docker container run --name rn1 diamol/ch06-random-number
Unable to find image 'diamol/ch06-random-number:latest' locally
latest: Pulling from diamol/ch06-random-number
941f399634ec: Already exists 
a9688c0f061a: Pull complete 
353e82f8473e: Pull complete 
d03cc88bf2c6: Pull complete 
Digest: sha256:aea876d5ff413b6e5f2d2bc13f0c70b562e7a2facc215798f22ca5344026e2ce
Status: Downloaded newer image for diamol/ch06-random-number:latest
sh-3.2# docker container run --name rn2 diamol/ch06-random-number
sh-3.2# docker ps
CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES
sh-3.2# docker ps -a
CONTAINER ID   IMAGE                       COMMAND                  CREATED          STATUS                      PORTS     NAMES
c87bfc9bb65e   diamol/ch06-random-number   "/bin/sh -c ./random…"   11 seconds ago   Exited (0) 10 seconds ago             rn2
1ed667b764d8   diamol/ch06-random-number   "/bin/sh -c ./random…"   16 seconds ago   Exited (0) 16 seconds ago             rn1
```

컨테이너를 실행하면 텍스트 파일에 무작위 숫자를 쓰는 스크립트가 실행된다. 그리고 컨테이너를 종료하면 Exited 상태가 된다. 이 두 컨테이너는 같은 이미지로부터 실행됐으나 파일 시스템의 내용은 서로 다르다. 2장에서 컨테이너를 종료해도 파일 시스템은 삭제되지 않는다고 배웠다. 그러므로 컨테이너의 파일과 디렉터리는 그대로 남아 있을 것이다.

`docker container cp` 명령을 사용해 컨테이너와 로컬 컴퓨터 간에 파일을 복사할 수 있다. 이 명령에 파일의 경로와 이름을 지정하면 무작위 숫자가 쓰인 텍스트 파일을 로컬 컴퓨터로 복사해 파일의 내용을 확인할 수 있다.

```docker
hee@yuhuijin-ui-MacBookAir practice % docker container cp rn1:/random/number.txt number1.txt
hee@yuhuijin-ui-MacBookAir practice % docker container cp rn2:/random/number.txt number2.txt
hee@yuhuijin-ui-MacBookAir practice % cat number1.txt 
2184
hee@yuhuijin-ui-MacBookAir practice % cat number2.txt
25785
```

두 컨테이너는 모두 같은 경로에 파일을 생성했다. 이 파일을 로컬 컴퓨터로 복사해서 내용을 확인해보니 두 파일의 내용이 서로 달랐다. 이로써 **컨테이너의 파일 시스템이 서로 독립적임을 알 수 있었다.** 여기서는 단지 파일 하나의 내용이지만, 같은 데이터베이스 엔진 이미지로 실행된 두 컨테이너가 서로 전혀 다른 데이터를 담을 수도 있는 것이다.

컨테이너의 파일 시스템은 단일 디스크(리눅스 컨테이너는 /dev/sda1, 윈도는 C:\)다. 그러나 이 디스크는 도커가 여러 출처로부터 합쳐 만들고 컨테이너에 전달한 가상 파일 시스템이다. 이 출처는 기본적으로 이미지 레이어와 컨테이너의 기록 가능 레이어로 구성되는데, 이미지 레이어는 모든 컨테이너가 공유하지만 기록 가능 레이어는 컨테이너마다 다르다.

그림 6-2에서 알 수 있는 두 가지 중요한 사실이 있다. 모든 컨테이너가 공유하는 이미지 레이어는 읽기 전용이고, 각 컨테이너가 따로 갖는 기록 가능 레이어(RW 레이어)는 컨테이너와 같은 생애주기를 갖는다. **이미지 레이어는 이미지를 내려받은 순간부터 삭제할 때까지 로컬 컴퓨터의 이미지 레이어에 존재한다. 그러나 컨테이너의 쓰기 가능 레이어는 컨테이너를 실행할 때 생성되며 컨테이너를 삭제할 때 함께 삭제된다.**(컨테이너를 종료하는 것만으로는 컨테이너가 삭제되지 않는다. 그래서 종료된 컨테이너의 데이터도 그대로 남아있는 것이다.)

기록 가능 레이어를 새 파일을 만드는 데만 사용하는 것은 아니다. 기존 이미지 레이어에 있는 파일을 수정할 수도 있다. 그러나 조금 전에 이미지 레이어는 읽기 전용이라고 하지 않았나? 여기에 바로 비밀이 있다. 도커는 기록중 복사(Copy-On-Write) 라는 방법을 사용해 읽기 전용 레이어의 파일을 수정할 수 있다. 컨테이너에서 이미지 레이어에 포함된 파일을 수정하려 하면, 먼저 도커가 이 파일을 쓰기 가능 레이어로 복사해 온 다음 쓰기 가능 레이어에서 파일을 수정한다.

```docker
sh-3.2# docker container run --name f1 diamol/ch06-file-display
Unable to find image 'diamol/ch06-file-display:latest' locally
latest: Pulling from diamol/ch06-file-display
941f399634ec: Already exists 
716aca3e500c: Already exists 
2755907779b3: Pull complete 
Digest: sha256:98c52776132a793d22524080e16a37db52de6a72dc5687cd5f6ae371d14dad12
Status: Downloaded newer image for diamol/ch06-file-display:latest
https://www.manning.com/books/learn-docker-in-a-month-of-lunches
sh-3.2# echo "http://eltonstoneman.com" > url.txt
sh-3.2# docker container cp url.txt f1:/input.txt
sh-3.2# docker container start --attach f1
http://eltonstoneman.com
```

이번에는 로컬 컴퓨터에서 컨테이너로 파일을 복사했다. 이 파일이 컨테이너가 내용을 출력하는 파일이다. 컨테이너를 재시작해 보면 똑같은 스크립트가 실행되며 파일의 내용을 출력하지만, 파일의 내용이 달라졌다.

컨테이너 속 파일을 수정하면 컨테이너의 동작에 영향을 미친다. 그러나 이미지를 공유하는 다른 컨테이너나 이미지는 영향을 받지 않는다. **수정된 파일은 해당 컨테이너의 기록 가능 레이어에만 존재하기 때문이다.** 새로운 컨테이너는 이미지로부터 받은 최초의 내용을 담은 파일 시스템을 가지며, f1 컨테이너가 삭제되면 수정된 파일도 사라진다.

```docker
hee@yuhuijin-ui-MacBookAir docker-playground % docker container run --name f2 diamol/ch06-file-display
https://www.manning.com/books/learn-docker-in-a-month-of-lunches
hee@yuhuijin-ui-MacBookAir docker-playground % docker container rm -f f1
f1
hee@yuhuijin-ui-MacBookAir docker-playground % docker container cp f1:/input.txt .
Error: No such container:path: f1:/input.txt
```

새로 실행한 컨테이너는 이미지로부터 받은 원래 내용의 파일을 사용하며, 처음 만든 컨테이너를 삭제하면 그 파일 시스템과 함께 수정된 파일도 사라진다.

컨테이너 파일 시스템은 컨테이너와 같은 생애주기를 갖는다. 컨테이너가 삭제되면 이 컨테이너의 기록 가능 레이어와 여기서 수정된 데이터도 함께 삭제된다. 도커를 사용하면 컨테이너 삭제를 밥 먹듯이 하게 된다. 실무에서는 새 이미지를 빌드하고 오래된 컨테이너를 삭제한 다음 새 이미지에서 실행한 컨테이너로 대체하는 방법으로 애플리케이션을 업데이트한다. 이 과정에서 기존 컨테이너에 있는 수정된 데이터는 모두 손실된다. 새 컨테이너는 이미지에서 받은 파일만 갖고 있기 때문이다.

애플리케이션이 계산 비용이 큰 계산 결과처럼 몇 가지 일시적 데이터를 캐싱만 하는 경우라면 새 컨테이너가 빈 캐시를 갖고 시작하더라도 문제가 없다. 하지만 그렇지 않은 경우라면 아마 재앙이 일어날 것이다. 컨테이너로 데이터베이스를 실행해 사용했는 데이터베이스 버전을 업데이트했더니 모든 데이터가 사라졌다고 생각해보자.

도커는 이런 상황도 감안해 만들어졌다. 컨테이너의 가상 파일 시스템은 여전히 이미지 레이어와 기록 가능 레이어로 구성되지만, 몇 가지 추가할 수 있는 요소가 더 있다. 도커 볼륨(Docker volume)과 마운트(mount)다. 이들 요소는 컨테이너와는 별개의 생애주기를 갖기 때문에 컨테이너가 대체돼도 지속돼야 할 데이터를 저장할 수 있다.

# 6.2 도커 볼륨을 사용하는 컨테이너 실행하기

도커 볼륨은 도커에서 스토리지를 다루는 단위다. 볼륨은 컨테이너와 독립적으로 존재하며 별도의 생애주기를 갖지만, 컨테이너에 연결할 수 있다. 볼륨을 생성해 애플리케이션 컨테이너에 연결하면 컨테이너 파일 시스템의 한 디렉터리가 된다. 나중에 애플리케이션을 업데이트하더라도 새로운 컨테이너에 다시 볼륨을 연결하면 데이터가 그대로 유지된다.

컨테이너가 볼륨을 사용하는 방법은 두가지다. 첫 번째는 수동으로 직접 볼륨을 생성해 컨테이너에 연결하는 방법이고, 두 번째는 Dockerfile 스크립트에서 `VOLUME` 인스트럭션을 사용하는 방법이다. 이 인스트럭션을 사용해 만든 이미지로 컨테이너를 실행하면 자동으로 볼륨을 생성한다. `VOLUME` 인스트럭션의 문법은 `VOLUME <target-directory>` 형식이다.

```docker
FROM diamol/dotnet-aspnet
WORKDIR /app
ENTRYPOINT ["dotnet", "ToDoList.dll"]

VOLUME /data
COPY --from=builder /out/ .
```

이 이미지로부터 컨테이너를 실행하면 자동으로 볼륨을 생성해 컨테이너에 연결해준다. 실행된 컨테이너에는 /data 디렉터리가 있는데, 이 디렉터리는 다른 디렉터리와 똑같이 사용할 수 있지만 이 디렉터리의 내용은 볼륨에 영구적으로 저장된다.

```docker
hee@yuhuijin-ui-MacBookAir todo-list % docker container run --name todo1 -d -p 8010:80 diamol/ch06-todo-list
Unable to find image 'diamol/ch06-todo-list:latest' locally
latest: Pulling from diamol/ch06-todo-list
f338bc35613f: Pull complete 
5636d912c69e: Pull complete 
362df8b85fca: Pull complete 
24c3992ceef4: Pull complete 
546a81dfea0f: Pull complete 
3e6d6e6fdcce: Pull complete 
697b28c7a381: Pull complete 
Digest: sha256:a7367ad4c81543d21f2b131a98c8e4c4fb75abe67df5d66ccdf34e0bd34f9b9a
Status: Downloaded newer image for diamol/ch06-todo-list:latest
ce1c0bf1dec3998a2061e1ee9012e9e190aaf6c66e56b178f8f846bf6b53fc3f
# Docker 컨테이너의 볼륨 정보 확인하기
hee@yuhuijin-ui-MacBookAir todo-list % docker container inspect --format '{{.Mounts}}' todo1
[{volume 975c02c3bfd523e9991ff06cf5b182126bfa3e5d31ec923230d243b5a657d5eb /var/lib/docker/volumes/975c02c3bfd523e9991ff06cf5b182126bfa3e5d31ec923230d243b5a657d5eb/_data /data local  true }]
hee@yuhuijin-ui-MacBookAir todo-list % docker volume ls
DRIVER    VOLUME NAME
local     975c02c3bfd523e9991ff06cf5b182126bfa3e5d31ec923230d243b5a657d5eb
```

컨테이너에서 동작하는 애플리케이션에서는 볼륨의 존재를 전혀 느낄 수 없다. 웹 브라우저에서 접근해보면 to-do 애플리케이션의 화면을 볼 수 있다. 이 애플리케이션은 데이터를 /data 디렉터리에 저장하는데, 웹 페이지에서 ‘할 일’을 하나 추가하면 도커 볼륨에 저장된다.

도커 이미지에 볼륨을 정의하면 컨테이너를 생성할 때마다 새로운 볼륨을 만든다. 하지만 컨테이너가 같은 볼륨을 공유하게 할 수도 있다. to-do 애플리케이션의 새로운 컨테이너를 그냥 실행하면 자신만의 볼륨을 생성하니 할일 목록이 비어있다. 그러나 `volumes-from` 플래그를 적용하면 다른 컨테이너의 볼륨을 연결할 수 있다.

```docker
hee@yuhuijin-ui-MacBookAir todo-list % docker container run --name todo2 -d diamol/ch06-todo-list
e1cb66025eb0cb36a23318d2087dae6ad785d69055f99f6e4078d370931277e7
hee@yuhuijin-ui-MacBookAir todo-list % docker container exec todo2 ls /data
hee@yuhuijin-ui-MacBookAir todo-list % docker container run -d --name t2 --volumes-from todo1 diamol/ch06-todo-l
ist
8c0a57dfcc0b15e37846aec8fded91256a73ae6778ee881eb4b8479f9ad9b477
hee@yuhuijin-ui-MacBookAir todo-list % docker container exec t2 ls /data
todo-list.db
```

두번째 컨테이너는 새로운 볼륨을 생성해 연결하기 때문에 /data 디렉터리가 비어있지만, 세 번째 컨테이너는 첫번째 컨테이너와 볼륨을 공유하므로 애플리케이션의 데이터를 세 번째 컨테이너의 디렉터리에서도 볼 수 있다.

컨테이너 간 볼륨 공유는 이해하긴 쉬워도 모든 일을 해결해 주지는 못한다. 애플리케이션 컨테이너는 종종 자신만이 접근할 수 있는 파일을 필요로 한다. 이러한 파일을 다른 컨테이너가 동시에 접근하게 허용하면 애플리케이션이 비정상적으로 동작할 수도 있다. 볼륨은 컨테이너 간 파일 공유보다는 업데이트 간 상태를 보존하기 위한 용도로 사용해야 하며, 이미지에서 정의하는 것보다는 명시적으로 관리하는 편이 더 낫다. 볼륨에 이름을 붙여 생성하고 업데이트 시 다른 컨테이너로 옮겨 연결하면 된다.

```docker
ee@yuhuijin-ui-MacBookAir todo-list % target='/data'
hee@yuhuijin-ui-MacBookAir todo-list % docker volume create todo-list
todo-list
hee@yuhuijin-ui-MacBookAir todo-list % docker container run -d -p 8011:80 -v todo-list:$target --name todo-v1 di
amol/ch06-todo-list
b509bc3a37e9ff065ebe236a4f364239413eb6418d47bf801d3ec5221cd37d7e
hee@yuhuijin-ui-MacBookAir todo-list % docker container rm -f todo-v1
todo-v1
hee@yuhuijin-ui-MacBookAir todo-list % docker container run -d -p 8011:80 -v todo-list:$target --name todo-v2 diamol/ch06-todo-list:v2
Unable to find image 'diamol/ch06-todo-list:v2' locally
v2: Pulling from diamol/ch06-todo-list
f338bc35613f: Already exists 
5636d912c69e: Already exists 
362df8b85fca: Already exists 
24c3992ceef4: Already exists 
546a81dfea0f: Already exists 
a70264aae6a4: Pull complete 
5b7dcfc5b742: Pull complete 
182e1a5c3e0e: Pull complete 
Digest: sha256:d2341450aaf2c48ed48e8607bd2271e5b89d38779487c746836d42ddafa5496c
Status: Downloaded newer image for diamol/ch06-todo-list:v2
4b8c6c8ada66a57213546ee1316d89c387a030594d6a07efe3928bebc9094934
```

![image.png](attachment:3a6d7e9f-bbd7-4718-a5b8-fcfe4e851136:image.png)

볼륨은 컨테이너보다 먼저 생성돼 자신과 연결됐던 컨테이너가 삭제된 뒤에도 그대로 남아 있다. 이로써 볼륨이 컨테이너와 별개의 생애주기를 가졌다는 것을 알 수 있다. 볼륨을 사용하면 컨테이너를 교체해 애플리케이션을 업데이트 하더라도 이렇게 데이터를 그대로 보존할 수 있다.

Dockerfile 스크립트의 `VOLUME` 인스트럭션과 `docker container` 명령의 `--volume` 플래그는 별개 기능이다. **`VOLUME` 인스트럭션을 사용해 빌드된 이미지로 `docker container run` 명령에서 볼륨을 지정하지 않으면 항상 새로운 볼륨을 함께 생성한다.** 이 볼륨은 무작위로 만들어진 식별자를 가지므로, 컨테이너를 삭제한 후 볼륨을 재사용하려면 이 식별자를 미리 기억해야 한다.

반면 **`--volume` 플래그는 이미지에 볼륨이 정의돼 있든 말든 지정된 볼륨을 컨테이너에 마운트한다.** 이미지에 볼륨이 정의돼 있더라도 이 정의가 무시되므로 새로운 볼륨이 생성되지 않는다. 지금 우리가 todo 애플리케이션을 업데이트한 과정이 바로 이 경우다.

이미지에 볼륨이 정의돼 있지 않아도 똑같은 결과를 얻는다. 이미지를 만드는 입장에서는 안전장치 삼아 `VOLUME` 인스트럭션을 이미지 정의에 포함시켜 두는 것이 좋다. 그러면 사용자가 볼륨을 지정하지 않더라도 데이터를 유실할 일이 없다. 하지만 역시 사용자 입장에서 보면, 이미지의 기본 볼륨 설정에 의존하지 말고 별도로 이름을 붙여 만든 볼륨을 사용하는 것이 좋다.

# 6.3 파일 시스템 마운트를 사용하는 컨테이너 실행하기

볼륨의 장점은 컨테이너와 스토리지의 생애주기를 분리하면서도 도커를 사용하는 방식 그대로 스토리지를 다룰 수 있는 점이다. 볼륨 역시 호스트 컴퓨터상에 존재하지만 컨테이너와는 분리돼 있기 때문이다. 하지만 호스트의 스토리지를 컨테이너에 좀 더 직접적으로 연결할 수 있는 수단이 있다. 바로 바인드 마운트(bind mount)다. **바인드 마운트는 호스트 컴퓨터 파일 시스템의 디렉터리를 컨테이너 파일 시스템의 디렉터리로 만든다.** 바인드 마운트도 볼륨과 마찬가지로 컨테이너의 입장에서는 그냥 평범한 디렉터리에 불과하다. 그러나 도커를 사용하는 입장에서는 컨테이너가 호스트 컴퓨터의 파일에 직접 접근할 수 있고 그 반대도 가능해지므로 좀 더 흥미로운 일을 할 수 있다.

바인드 마운트를 사용하면 호스트 컴퓨터의 파일 시스템을 명시적으로 지정해 컨테이너 데이터로 쓸 수 있다. 속도 면에서 뛰어난 SSD 디스크, 고사용성 디스크 어레이, 네트워크 상에서 사용하는 분산 스토리지까지 호스트 컴퓨터에서 접근 가능한 파일 시스템이라면 무엇이든 컨테이너에서도 사용할 수 있다. 만약 RAID가 적용된 디스크 어레이를 가진 서버가 있다면, 이 스토리지를 to-do 앱의 데이터베이스를 저장할 고신뢰성 스토리지로 활용할 수도 있다.
