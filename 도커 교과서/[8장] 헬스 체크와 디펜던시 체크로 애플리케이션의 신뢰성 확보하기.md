# 8.1 헬스 체크를 지원하는 도커 이미지 빌드하기

도커는 컨테이너를 시작할 때마다 애플리케이션의 기본적인 상태를 확인한다. 컨테이너를 실행하면 내부에서 애플리케이션 실행 파일이나 자바 혹은 닷넷 런타임, 또는 셸 스크립트 같은 특정한 프로세스가 실행되는데, 도커가 확인하는 것은 이 프로세스의 실행 상태다. 만약 이 프로세스가 종료됐다면 컨테이너도 종료 상태가 된다.

이것만으로도 환경과 상관없이 기본적인 헬스 체크는 가능하다. 해당 프로세스가 비정상 종료됐거나 컨테이너가 종료됐다면 개발자도 애플리케이션의 상태가 비정상임을 알 수 있다. 클러스터 환경에서는 플랫폼이 종료된 컨테이너를 재시작하거나 새 컨테이너로 교체하는 작업을 대신 해준다. 그러나 이 정도는 아주 기초적인 수준에 불과하다. 이정도 수준에서 보장되는 것은 프로세스가 실행 상태라는 점뿐이지 애플리케이션의 정상적인 상태가 아니다. 웹 애플리케이션을 실행중인 컨테이너를 떠올려보자. 이 컨테이너의 처리 용량을 뛰어넘는 수의 요청이 들어오는 순간 웹 애플리케이션은 503 ‘Service Unavailable’ 오류를 뿜을 것이다. 하지만 컨테이너의 프로세스는 여전히 정상적으로 실행중이다. 애플리케이션이 동작을 멈췄어도 도커는 컨테이너를 정상이라 판단한다.

도커는 애플리케이션의 상태가 실제로 정상인지 확인할 수 있는 정보를 도커 이미지에 직접 넣을 수 있다. 방법도 간단하다. Dockerfile 스크립트에 상태 확인을 위한 로직을 추가하면 된다.

```yaml
hee@yuhuijin-ui-MacBookAir numbers % docker container run -d -p 8080:80 diamol/ch08-numbers-api
Unable to find image 'diamol/ch08-numbers-api:latest' locally
latest: Pulling from diamol/ch08-numbers-api
f338bc35613f: Already exists 
5636d912c69e: Already exists 
362df8b85fca: Already exists 
24c3992ceef4: Already exists 
546a81dfea0f: Already exists 
e26e4cba9e8c: Pull complete 
c606dfac132b: Pull complete 
Digest: sha256:0dcd49f3ecd0d050c0a8cc6c5f516ea37d316b620c5c6839c53b523bc2f5fb7a
Status: Downloaded newer image for diamol/ch08-numbers-api:latest
37b4a318430af44909308f523f67480068e36f2114682ab8543275f190abef58
hee@yuhuijin-ui-MacBookAir numbers % curl http://localhost:8080/rng
83%                                                                                                             
hee@yuhuijin-ui-MacBookAir numbers % curl http://localhost:8080/rng
20%                                                                                                             
hee@yuhuijin-ui-MacBookAir numbers % curl http://localhost:8080/rng
83%                                                                                                             
hee@yuhuijin-ui-MacBookAir numbers % curl http://localhost:8080/rng
{"type":"https://tools.ietf.org/html/rfc7231#section-6.6.1","title":"An error occured while processing your request.","status":500,"traceId":"|f9d6199e-42033c14bba9bfe6."}%                                                    
hee@yuhuijin-ui-MacBookAir numbers % docker container ls
CONTAINER ID   IMAGE                          COMMAND                  CREATED          STATUS          PORTS                   NAMES
37b4a318430a   diamol/ch08-numbers-api        "dotnet /app/Numbers…"   28 seconds ago   Up 27 seconds   0.0.0.0:8080->80/tcp    confident_gates 
```

컨테이너 목록을 확인하면 해당 컨테이너의 상태는 여전히 Up으로 나온다. 컨테이너 안에서 동작하는 프로세스의 상태도 역시 실행중이다.

Dockerfile에서 `HEALTHCHECK` 인스트럭션을 보자. 컨테이너 런타임은 이 인스트럭션에 정의된 정보를 이용해 컨테이너에서 동작중인 애플리케이션 상태가 정상인지 확인할 수 있다. `HEALTHCHECK` 인스트럭션에는 도커가 컨테이너 안에서 실행하는 명령을 지정하게 되는데, 이 명령이 반환하는 상태 코드를 보고 애플리케이션의 상태를 판단한다. 애플리케이션의 상태를 판단할 수 있다면 어떤 명령을 지정해도 무방하다. 도커는 일정한 시간 간격으로 컨테이너 안에서 지정된 명령을 실행한다. 상태 코드가 정상이면 컨테이너도 정상으로 간주되지만, 상태 코드가 연속으로 일정 횟수 이상 실패로 나오면 해당 컨테이너를 이상 상태로 간주한다.

```yaml
hee@yuhuijin-ui-MacBookAir numbers % docker image build -t diamol/ch08-numbers-api:v2 -f ./numbers-api/Dockerfile.v2 .
[+] Building 25.8s (15/15) FINISHED                                                                                                                        
 => [internal] load build definition from Dockerfile.v2                                                                                               0.0s
 => => transferring dockerfile: 433B                                                                                                                  0.0s
 => [internal] load .dockerignore                                                                                                                     0.0s
 => => transferring context: 2B                                                                                                                       0.0s
 => [internal] load metadata for docker.io/diamol/dotnet-aspnet:latest                                                                                3.2s
 => [internal] load metadata for docker.io/diamol/dotnet-sdk:latest                                                                                   3.3s
 => [builder 1/6] FROM docker.io/diamol/dotnet-sdk@sha256:a78173a9dbd3e6b3b2af1eadad3edd6e8ef7b2801f3cda405928e5da155c7039                           18.7s
 => => resolve docker.io/diamol/dotnet-sdk@sha256:a78173a9dbd3e6b3b2af1eadad3edd6e8ef7b2801f3cda405928e5da155c7039                                    0.0s
 => => sha256:0835e3317ad7d6a1c55bb55dfbef8e643050fbc7788cee4c28d8e64f8eeb4d8b 6.60kB / 6.60kB                                                        0.0s
 => => sha256:5a8521f5974d84ca2cef7f3a1ec71cce08198a563735e8d8d7c603536146819c 49.17MB / 49.17MB                                                      6.1s
 => => sha256:dd1378028f1d64d56a341de0c01136ac13cc193af54fb3c785e7ee29a493d09c 7.68MB / 7.68MB                                                        1.0s
 => => sha256:15cab53b0844e637da16aa62d159100c6022d0c9eada7037f946abce70764bcf 9.98MB / 9.98MB                                                        3.1s
 => => sha256:a78173a9dbd3e6b3b2af1eadad3edd6e8ef7b2801f3cda405928e5da155c7039 1.41kB / 1.41kB                                                        0.0s
 => => sha256:47ee6d34eb269549840f9ea68b71ed38f83612425dd57edf48ce7f5e0da1de3d 2.01kB / 2.01kB                                                        0.0s
 => => sha256:f6b3955dadc05d892a1e30426b7e75cd5a2c5e7d0f8a43ea4931e5207d66f850 52.10MB / 52.10MB                                                      6.6s
 => => sha256:f5f2dd32efaccdce5ce7f28283b8f280af0c455b3bc73be174dad60dc55b6c2c 13.88MB / 13.88MB                                                      6.4s
 => => sha256:a234be1bd33348046c1617ab990ce4abbbb306415119feee9687d2555f22522d 116.09MB / 116.09MB                                                   14.9s
 => => extracting sha256:5a8521f5974d84ca2cef7f3a1ec71cce08198a563735e8d8d7c603536146819c                                                             1.1s
 => => sha256:d29376217192fcdc16c604a37cf25ea3dd98deef344b23fb31eed147d8adb4f9 11.85MB / 11.85MB                                                      9.7s
 => => sha256:60f466545096a0c2271a5807cfdea54f74426dba4ad4f36f491571682f215aea 6.33kB / 6.33kB                                                        7.3s
 => => extracting sha256:dd1378028f1d64d56a341de0c01136ac13cc193af54fb3c785e7ee29a493d09c                                                             0.1s
 => => extracting sha256:15cab53b0844e637da16aa62d159100c6022d0c9eada7037f946abce70764bcf                                                             0.1s
 => => extracting sha256:f6b3955dadc05d892a1e30426b7e75cd5a2c5e7d0f8a43ea4931e5207d66f850                                                             1.4s
 => => extracting sha256:f5f2dd32efaccdce5ce7f28283b8f280af0c455b3bc73be174dad60dc55b6c2c                                                             0.3s
 => => extracting sha256:a234be1bd33348046c1617ab990ce4abbbb306415119feee9687d2555f22522d                                                             2.5s
 => => extracting sha256:60f466545096a0c2271a5807cfdea54f74426dba4ad4f36f491571682f215aea                                                             0.0s
 => => extracting sha256:d29376217192fcdc16c604a37cf25ea3dd98deef344b23fb31eed147d8adb4f9                                                             0.3s
 => [stage-1 1/3] FROM docker.io/diamol/dotnet-aspnet@sha256:d34a231013982f446e54fe15c036bf5e8585ae8e95ff1fd3e0c374a40d3f60f7                         0.1s
 => => resolve docker.io/diamol/dotnet-aspnet@sha256:d34a231013982f446e54fe15c036bf5e8585ae8e95ff1fd3e0c374a40d3f60f7                                 0.0s
 => => sha256:d34a231013982f446e54fe15c036bf5e8585ae8e95ff1fd3e0c374a40d3f60f7 1.41kB / 1.41kB                                                        0.0s
 => => sha256:69a6fbac50e32ea8e25fec3261466bab5049da72271db6b942eec380521eed62 1.38kB / 1.38kB                                                        0.0s
 => => sha256:f35f5f0e483eb53226e879bb39e684fb45b37877f4a7660c3a2e8b71224246bb 4.71kB / 4.71kB                                                        0.0s
 => [internal] load build context                                                                                                                     0.0s
 => => transferring context: 4.42kB                                                                                                                   0.0s
 => [stage-1 2/3] WORKDIR /app                                                                                                                        0.0s
 => [builder 2/6] WORKDIR /src                                                                                                                        1.3s
 => [builder 3/6] COPY src/Numbers.Api/Numbers.Api.csproj .                                                                                           0.0s
 => [builder 4/6] RUN dotnet restore                                                                                                                  0.6s
 => [builder 5/6] COPY src/Numbers.Api/ .                                                                                                             0.0s
 => [builder 6/6] RUN dotnet publish -c Release -o /out Numbers.Api.csproj                                                                            1.6s
 => [stage-1 3/3] COPY --from=builder /out/ .                                                                                                         0.0s
 => exporting to image                                                                                                                                0.0s
 => => exporting layers                                                                                                                               0.0s
 => => writing image sha256:f889fa0cc627e41a73afae81952aee66ec474544a542a734a8c1e7141d8f3ae5                                                          0.0s
 => => naming to docker.io/diamol/ch08-numbers-api:v2                                                                                                 0.0s
hee@yuhuijin-ui-MacBookAir numbers % 
```

이 이미지 빌드가 끝나면 헬스 체크 기능을 갖춘 애플리케이션을 실행할 수 있다. 여기에 더해 헬스 체크 간격과 애플리케이션의 상태를 이상으로 간주하는 누적 실패 횟수도 설정할 수 있다. 기본값은 30초 간격으로 연속 3회 이상 실패하면 애플리케이션이 이상 상태로 간주된다. 새로 빌드한 버전 v2 이미지는 이제 헬스 체크 기능을 내장했으므로 테스트를 다시 해 보면 컨테이너의 이상을 감지할 수 있다.

```yaml
hee@yuhuijin-ui-MacBookAir numbers % docker container run -d -p 8081:80 diamol/ch08-numbers-api:v2                    
168cd8097eb8020b9e1a4eff7c0154e812fcc4fd089d468958b407bc2d514dc0
hee@yuhuijin-ui-MacBookAir numbers % docker container ls
CONTAINER ID   IMAGE                          COMMAND                  CREATED          STATUS                             PORTS                   NAMES
168cd8097eb8   diamol/ch08-numbers-api:v2     "dotnet /app/Numbers…"   11 seconds ago   Up 11 seconds (health: starting)   0.0.0.0:8081->80/tcp    gifted_bartik
37b4a318430a   diamol/ch08-numbers-api        "dotnet /app/Numbers…"   18 minutes ago   Up 18 minutes                      0.0.0.0:8080->80/tcp    confident_gates
9ebfa3b37d72   diamol/ch04-image-gallery      "/web/server"            25 hours ago     Up 25 hours                        0.0.0.0:8010->80/tcp    image-of-the-day-image-gallery-1
35c1507bd03d   diamol/ch04-image-of-the-day   "java -jar /app/iotd…"   25 hours ago     Up 25 hours                        0.0.0.0:58191->80/tcp   image-of-the-day-iotd-2
43b996ffecfa   diamol/ch04-access-log         "docker-entrypoint.s…"   25 hours ago     Up 25 hours                        80/tcp                  image-of-the-day-accesslog-1
b9836396bc9f   diamol/ch06-todo-list          "dotnet ToDoList.dll"    36 hours ago     Up 36 hours                        0.0.0.0:8020->80/tcp    practice-todo-web-1
hee@yuhuijin-ui-MacBookAir numbers % curl http://localhost:8081/rng
96%                                                                                                                                                        
hee@yuhuijin-ui-MacBookAir numbers % curl http://localhost:8081/rng
81%                                                                                                                                                        
hee@yuhuijin-ui-MacBookAir numbers % curl http://localhost:8081/rng
1%                                                                                                                                                         
hee@yuhuijin-ui-MacBookAir numbers % curl http://localhost:8081/rng
{"type":"https://tools.ietf.org/html/rfc7231#section-6.6.1","title":"An error occured while processing your request.","status":500,"traceId":"|6676dcc0-4ab27fb6d10f91d5."}%                                                                                                                                          
hee@yuhuijin-ui-MacBookAir numbers % docker container ls
CONTAINER ID   IMAGE                          COMMAND                  CREATED              STATUS                          PORTS                   NAMES
168cd8097eb8   diamol/ch08-numbers-api:v2     "dotnet /app/Numbers…"   About a minute ago   Up About a minute (unhealthy)   0.0.0.0:8081->80/tcp    gifted_bartik
37b4a318430a   diamol/ch08-numbers-api        "dotnet /app/Numbers…"   19 minutes ago       Up 19 minutes                   0.0.0.0:8080->80/tcp    confident_gates
9ebfa3b37d72   diamol/ch04-image-gallery      "/web/server"            25 hours ago         Up 25 hours                     0.0.0.0:8010->80/tcp    image-of-the-day-image-gallery-1
35c1507bd03d   diamol/ch04-image-of-the-day   "java -jar /app/iotd…"   25 hours ago         Up 25 hours                     0.0.0.0:58191->80/tcp   image-of-the-day-iotd-2
43b996ffecfa   diamol/ch04-access-log         "docker-entrypoint.s…"   25 hours ago         Up 25 hours                     80/tcp                  image-of-the-day-accesslog-1
b9836396bc9f   diamol/ch06-todo-list          "dotnet ToDoList.dll"    36 hours ago         Up 36 hours                     0.0.0.0:8020->80/tcp    practice-todo-web-1
```

컨테이너의 이상 상태는 도커 API를 통해 보고된다. 따라서 컨테이너를 실행중인 플랫폼도 컨테이너의 이상 상태를 통보받고 애플리케이션을 복구하기 위한 조치를 취할 수 있다. 그리고 가장 최근의 헬스 체크 수행 결과도 저장돼 있어 컨테이너의 상태를 조사할 때 이 결과를 열람할 수 있다. 컨테이너 상태를 보여주는 `docker container inspect` 명령의 결과는 앞서 실습에서 이미 봤다. 헬스 체크가 수행중이라면 그 결과 역시 `inspect` 명령에서 볼 수 있다.

```yaml
hee@yuhuijin-ui-MacBookAir numbers % docker container inspect $(docker container ls --last 1 --format '{{.ID}}')
[
    {
        "Id": "168cd8097eb8020b9e1a4eff7c0154e812fcc4fd089d468958b407bc2d514dc0",
        "Created": "2026-02-12T02:06:07.009494385Z",
        "Path": "dotnet",
        "Args": [
            "/app/Numbers.Api.dll"
        ],
        "State": {
            "Status": "running",
            "Running": true,
            "Paused": false,
            "Restarting": false,
            "OOMKilled": false,
            "Dead": false,
            "Pid": 29429,
            "ExitCode": 0,
            "Error": "",
            "StartedAt": "2026-02-12T02:06:07.30218901Z",
            "FinishedAt": "0001-01-01T00:00:00Z",
            "Health": {
                "Status": "unhealthy",
                "FailingStreak": 9,
                "Log": [
                    {
                        "Start": "2026-02-12T02:08:37.753586511Z",
                        "End": "2026-02-12T02:08:37.842226844Z",
                        "ExitCode": 22,
                        "Output": "  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\ncurl: (22) The requested URL returned error: 500 Internal Server Error\n"
                    },
                    {
                        "Start": "2026-02-12T02:09:07.844202552Z",
                        "End": "2026-02-12T02:09:07.934590677Z",
                        "ExitCode": 22,
                        "Output": "  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\ncurl: (22) The requested URL returned error: 500 Internal Server Error\n"
                    },
                    {
                        "Start": "2026-02-12T02:09:37.944531844Z",
                        "End": "2026-02-12T02:09:38.030322386Z",
                        "ExitCode": 22,
                        "Output": "  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\ncurl: (22) The requested URL returned error: 500 Internal Server Error\n"
                    },
                    {
                        "Start": "2026-02-12T02:10:08.039914719Z",
                        "End": "2026-02-12T02:10:08.179976386Z",
                        "ExitCode": 22,
                        "Output": "  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\ncurl: (22) The requested URL returned error: 500 Internal Server Error\n"
                    },
                    {
                        "Start": "2026-02-12T02:10:38.189087594Z",
                        "End": "2026-02-12T02:10:38.288385052Z",
                        "ExitCode": 22,
                        "Output": "  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\r  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0\ncurl: (22) The requested URL returned error: 500 Internal Server Error\n"
                    }
                ]
            }
        },
      ...
```

`State` 필드를 찾아보면 그 아래 `Health` 필드가 보인다. 이 필드에서 현재의 헬스 체크 상태를 볼 수 있다. `FailingStreak`은 연속 실패한 횟수이고 `Log`는 가장 최근에 수행한 헬스 체크의 정보다. 헬스 체크 명령에서 코드 500이 나오면 실패가 되는데, 헬스 체크가 연속으로 9번 실패하면 컨테이너의 상태가 `unhealthy`로 바뀐다.

그런데 애플리케이션이 이상 상태임에도 컨테이너의 상태는 여전히 실행 중이라고 나온다. 왜 이상 상태에 있는 컨테이너를 재시작하거나 다른 컨테이너로 교체하지 않은 것일까? 그 이오는 도커가 이런 작업을 안전하게 처리할 수 없기 때문이다. 도커 엔진은 단일 서버에서 동작하는데, 이상이 생긴 컨테이너를 도커가 중지하고 재시작할 수는 있지만 그 시간 동안에는 애플리케이션이 동작하지 않는다. 이상이 생긴 컨테이너를 제거하고 완전히 같은 설정으로 새 컨테이너를 실행할 수도 있지만, 이 경우에도 컨테이너에 보관된 데이터가 유실되고 그 시간 동안 애플리케이션도 동작하지 않는다. 도커 입장에서는 이상 상태를 보이는 컨테이너를 교체하는 작업을 직접 수행했을 때 상황을 더 악화시키지 않을 것이라는 보장이 없으므로, 이상 상태 발생을 통보만 할 뿐 컨테이너는 그대로 두는 것이다. 물론 헬스 체크도 계속 수행된다. 일시적인 헬스 체크 실패일 뿐이었다면 컨테이너의 상태가 다시 정상으로 돌아간다.

# 8.2 디펜던시 체크가 적용된 컨테이너 실행하기

```yaml
hee@yuhuijin-ui-MacBookAir numbers % docker container rm -f $(docker container ls -aq)
168cd8097eb8
37b4a318430a
9ebfa3b37d72
35c1507bd03d
43b996ffecfa
b9836396bc9f
hee@yuhuijin-ui-MacBookAir numbers % docker container run -d -p 8082:80 diamol/ch08-numbers-web
Unable to find image 'diamol/ch08-numbers-web:latest' locally
latest: Pulling from diamol/ch08-numbers-web
f338bc35613f: Already exists 
5636d912c69e: Already exists 
362df8b85fca: Already exists 
24c3992ceef4: Already exists 
546a81dfea0f: Already exists 
83cc1b960aa6: Pull complete 
c0b211fa085e: Pull complete 
Digest: sha256:20c6eb1a6d449b2935cee7a72c1758d34013a09033894ca3377f3a7d6ac28b01
Status: Downloaded newer image for diamol/ch08-numbers-web:latest
51bea50c6e35d66a88effe9e5193ee293624719599dc89bb39812ef65496bc8a
hee@yuhuijin-ui-MacBookAir numbers % docker container ls
CONTAINER ID   IMAGE                     COMMAND                  CREATED         STATUS         PORTS                  NAMES
51bea50c6e35   diamol/ch08-numbers-web   "dotnet /app/Numbers…"   3 seconds ago   Up 3 seconds   0.0.0.0:8082->80/tcp   fervent_vaughan
hee@yuhuijin-ui-MacBookAir numbers % 
```

컨테이너 상태는 정상인데 핵심 의존 관계를 만족하지 않아 애플리케이션이 정상적으로 동작하지 않는 상황은 누구나 사양하고 싶을 것이다. 애플리케이션 중에는 실행 시 필요한 의존 관계를 미리 확인하는 로직을 포함한 것도 있지만, 대부분의 애플리케이션은 이런 로직이 없다. 우리가 실행한 무작위 숫자 웹 애플리케이션도 API가 동작 중인 상태를 상정하고 동작하지만 별도로 의존 관계를 확인하진 않았다.

의존 관계를 만족하는지 점검하는 디펜던시 체크 기능도 도커 이미지에 추가할 수 있다. 디펜던시 체크는 애플리케이션 실행 전에 필요한 요구 사항을 확인하는 기능으로, 실행 시점이 헬스 체크와는 조금 다르다. 모든 요구 사항이 확인되면 디펜던시 체크가 성공하고 애플리케이션이 실행된다. 반대로 만족하지 못하는 요구사항이 있다면 디펜던시 체크가 실패해 애플리케이션이 실행되지 않는다. 디펜던시 체크는 헬스 체크처럼 별도의 인스트럭션으로 도커에 구현된 것은 아니고 애플리케이션 실행 명령에 로직을 추가하는 방법으로 구현한다.

API 사용 가능 여부를 확인하기 위해 이번에도 기반 이미지에 포함된 유틸리티인 `curl`을 사용한다. `CMD` 인스트럭션에 정의된 명령은 컨테이너를 실행할 때 실행된다. 이 명령은 API에 HTTP 요청을 보내 API 가 사용 가능한지 확인한다. 그 뒤에 이어지는 `&&`는 리눅스와 윈도 셸 모두에서 기능이 같다.

API가 사용 가능한 상태라면 `curl` 명령이 성공하고 이어지는 닷넷 코어 애플리케이션 실행 명령을 실행할 것이며, 도커가 이어서 `dotnet` 프로세스의 상태를 모니터링 할 것이다. API를 사용할 수 없다면 `curl`명령이 실패하고 뒤에 오는 명령도 실행되지 않아 컨테이너가 그대로 종료된다.

```yaml
hee@yuhuijin-ui-MacBookAir numbers % docker container run -d -p 8084:80 diamol/ch08-numbers-web:v2
Unable to find image 'diamol/ch08-numbers-web:v2' locally
v2: Pulling from diamol/ch08-numbers-web
f338bc35613f: Already exists 
5636d912c69e: Already exists 
362df8b85fca: Already exists 
24c3992ceef4: Already exists 
546a81dfea0f: Already exists 
45d207aef600: Pull complete 
4e7a3270e424: Pull complete 
Digest: sha256:97818270bc82f5558acad637b7237de98868092cd540c72456bf79bf17029abd
Status: Downloaded newer image for diamol/ch08-numbers-web:v2
a59c82503c161506af5ee71722dd11aba0f7eb7610c0951d0921a641e500c11d
hee@yuhuijin-ui-MacBookAir numbers % docker container ls --all
CONTAINER ID   IMAGE                        COMMAND                  CREATED          STATUS                     PORTS                  NAMES
a59c82503c16   diamol/ch08-numbers-web:v2   "/bin/sh -c 'curl --…"   15 seconds ago   Exited (6) 9 seconds ago                          eloquent_gagarin
51bea50c6e35   diamol/ch08-numbers-web      "dotnet /app/Numbers…"   11 minutes ago   Up 11 minutes              0.0.0.0:8082->80/tcp   fervent_vaughan
hee@yuhuijin-ui-MacBookAir numbers % 

```

컨테이너가 종료되면 컨테이너 플랫폼이 대체할 새로운 컨테이너를 마련한다. 예를 들어 API 컨테이너를 실행하는 데 시간이 오래 걸린다면 웹 애플리케이션이 실행될 때 API가 준비되지 않았을 수도 있다. 이럴 때는 그냥 웹 애플리케이션 컨테이너가 종료되고 API 준비가 끝났을 때 대체 컨테이너를 실행하면 된다.

# 8.3 애플리케이션 체크를 위한 커스텀 유틸리티 만들기

`curl`은 웹 애플리케이션이나 API를 테스트하는데 매우 유용한 도구다. 하지만 실무에서 개발하는 애플리케이션을 테스트하는 목적으로는 `curl`을 사용하지 않는다. 보안 정책상의 이유로 이미지에 `curl` 을 포함시킬 수 없기 때문이다.

도커 이미지에는 애플리케이션을 구동하는데 필요한 최소한의 내용만 들어가야 한다. `curl`이 컨테이너 상태 체크에 유용한 도구이기는 하나 이런 이유로 실제 애플리케이션 체크에는 커스텀 유틸리티를 사용하는 것이 낫다.

애플리케이션과 같은 언어로 구현된 커스텀 유틸리티의 장점은 다음과 같다.

- 커스텀 유틸리티를 실행할 때도 애플리케리션과 같은 도구를 사용하므로 이미지에 추가적인 소프트웨어를 포함시킬 필요가 없다.
- 재시도 횟수나 분기 등 셸 스크립트로는 표현하기 까다로운 복잡한 체크 로직을 적용할 수 있다. 특히 리눅스와 윈도 양쪽에서 사용할 크로스 플랫폼 이미지라면 더욱 유용하다.
- 애플리케이션과 같은 설정을 사용해 대상 URL을 여러 곳에 반복 정의하거나 수정에서 누락시키는 일을 방지할 수 있다.
- 애플리케이션과 같은 라이브러리 환경에서 데이터베이스 접속이나 인증서 파일의 존재 유무 등 컨테이너 실행 전에 확인이 필요한 모든 사항을 검증할 수 있다.

다양한 상황에서 동작이 가능하다는 것도 장점이다.

```docker
# app image
FROM diamol/dotnet-aspnet

ENTRYPOINT ["dotnet", "Numbers.Api.dll"]
HEALTHCHECK CMD ["dotnet", "Utilities.HttpCheck.dll", "-u", "http://localhost/health"]

WORKDIR /app
COPY --from=http-check-builder /out/ .
COPY --from=builder /out/ .
```

수정된 헬스 체크도 동작은 거의 그대로다. 차이점은 컨테이너 검사 중 출력되는 로그가 좀 적어진다는 정도다. 따라서 헬스 체크 수행 한 번에 한 줄의 결과만 출력된다. 애플리케이션의 초기 상태도 정상으로 나온다. API를 몇 번 호출하고 나면 이상 상태를 보고할 것이다.

```docker
hee@yuhuijin-ui-MacBookAir 도커 교과서 % docker container rm -f $(docker container ls -aq)
a59c82503c16
51bea50c6e35
hee@yuhuijin-ui-MacBookAir 도커 교과서 % docker container run -d -p 8080:80 --health-interval 5s diamol/ch08-num
bers-api:v3
Unable to find image 'diamol/ch08-numbers-api:v3' locally
v3: Pulling from diamol/ch08-numbers-api
f338bc35613f: Already exists 
5636d912c69e: Already exists 
362df8b85fca: Already exists 
24c3992ceef4: Already exists 
546a81dfea0f: Already exists 
a1d31c83c9fb: Pull complete 
b4b21f2c15f2: Pull complete 
5b2370cbc2a2: Pull complete 
Digest: sha256:8e01f3f3fa0cc3596a979930437dacb425b3047436513f2615a87063a45b7491
Status: Downloaded newer image for diamol/ch08-numbers-api:v3
ca8c30077fe679c9b2e7a526879c6e4017905f536136c13866022cafd52f9b33
hee@yuhuijin-ui-MacBookAir 도커 교과서 % docker container ls
CONTAINER ID   IMAGE                        COMMAND                  CREATED          STATUS                    PORTS                  NAMES
ca8c30077fe6   diamol/ch08-numbers-api:v3   "dotnet Numbers.Api.…"   12 seconds ago   Up 12 seconds (healthy)   0.0.0.0:8080->80/tcp   nifty_panini
hee@yuhuijin-ui-MacBookAir 도커 교과서 % curl http://localhost:8080/rng
11%                                                                                                             
hee@yuhuijin-ui-MacBookAir 도커 교과서 % curl http://localhost:8080/rng
36%                                                                                                             
hee@yuhuijin-ui-MacBookAir 도커 교과서 % curl http://localhost:8080/rng
75%                                                                                                             
hee@yuhuijin-ui-MacBookAir 도커 교과서 % curl http://localhost:8080/rng
{"type":"https://tools.ietf.org/html/rfc7231#section-6.6.1","title":"An error occured while processing your request.","status":500,"traceId":"|c3a32456-49bcd0cc359a11de."}%                                                    
hee@yuhuijin-ui-MacBookAir 도커 교과서 % docker container ls
CONTAINER ID   IMAGE                        COMMAND                  CREATED          STATUS                    PORTS                  NAMES
ca8c30077fe6   diamol/ch08-numbers-api:v3   "dotnet Numbers.Api.…"   37 seconds ago   Up 37 seconds (healthy)   0.0.0.0:8080->80/tcp   nifty_panini
hee@yuhuijin-ui-MacBookAir 도커 교과서 % docker container ls
CONTAINER ID   IMAGE                        COMMAND                  CREATED          STATUS                      PORTS                  NAMES
ca8c30077fe6   diamol/ch08-numbers-api:v3   "dotnet Numbers.Api.…"   55 seconds ago   Up 55 seconds (unhealthy)   0.0.0.0:8080->80/tcp   nifty_panini
```

```docker
FROM diamol/dotnet-aspnet

ENV RngApi:Uri=http://numbers-api/rng

CMD dotnet Urilities.HttpCheck.dll -c RngApi:Url -t 900 && \
	dotnet Numbers.Web.dll
	
WORKDIR /app
COPY --from=http-check-builder /out/ .
COPY --from=builder /out/ .
```

여기서 사용한 `-t` 옵션은 유틸리티가 요청에 대한 응답을 기다릴 제한 시간을 설정한 것이고, `-c` 옵션은 애플리케이션과 같은 설정 파일을 읽어 그 설정대로 대상 URL을 지정한 것이다.

이제 동작은 똑같이 유지하면 애플리케이션 이미지에서 `curl`을 제거할 수 있게 됐다.

```docker
hee@yuhuijin-ui-MacBookAir 도커 교과서 % docker container run -d -p 8081:80 diamol/ch08-numbers-web:v3
Unable to find image 'diamol/ch08-numbers-web:v3' locally
v3: Pulling from diamol/ch08-numbers-web
f338bc35613f: Already exists 
5636d912c69e: Already exists 
362df8b85fca: Already exists 
24c3992ceef4: Already exists 
546a81dfea0f: Already exists 
2c6f18abfee2: Pull complete 
c8933103e3d5: Pull complete 
fae779850b6e: Pull complete 
Digest: sha256:9908c8543297e98afbb3d5b7eaa198d4e0896402a813e3aa99e2e87fab25c42d
Status: Downloaded newer image for diamol/ch08-numbers-web:v3
83420e7fcb0061686481da499c8aed8c420fe55285672fc6fd60b229efa9d0db
hee@yuhuijin-ui-MacBookAir 도커 교과서 % docker container ls -all
CONTAINER ID   IMAGE                        COMMAND                  CREATED         STATUS                     PORTS     NAMES
83420e7fcb00   diamol/ch08-numbers-web:v3   "/bin/sh -c 'dotnet …"   8 seconds ago   Exited (1) 2 seconds ago             thirsty_agnesi
```

커스텀 테스트 유틸리티를 따로 마련하는 또 한 가지 장점은 이미지의 이식성이 향상된다는 것이다. 컨테이너 플랫폼마다 헬스 체크와 디펜던시 체크를 정의하고 실행하는 방법에 차이가 있다. 그러나 모든 로직을 테스트 유틸리티에 포함시킨다면 도커 컴포즈, 도커 스웜, 쿠버네티스 등 어떤 환경에서도 그대로 동작시킬 수 있다.

# 8.4 도커 컴포즈에 헬스 체크와 디펜던시 체크 정의하기

도커 컴포즈는 애플리케이션의 상태에 이상이 생겼을 때 어느 정도 복원할 수 있는 기능이 있다. 그러나 도커 컴포즈도 이상이 생긴 컨테이너를 새 컨테이너로 대체하지는 않는다. 단일 서버에서 애플리케이션을 실행중이라면 더 심각한 장애를 일으킬 수 있기 때문이다. 하지만 종료된 컨테이너를 재시작하거나 이미지에 정의되지 않은 헬스 체크를 추가할 수는 있다.

도커 컴포즈 파일에서는 헬스 체크의 옵션을 더 세세하게 설정할 수 있다.

- `interval`은 헬스 체크 실시 간격을 의미한다. 여기서는 5초로 설정됐다.
- `timeout`은 그때까지 응답을 받지 못하면 실패로 간주하는 제한 시간을 의미한다.
- `retries`는 컨테이너 상태를 이상으로 간주할 때까지 필요한 연속 실패 횟수를 의미한다.
- `start_period`는 컨테이너 실행 후 첫 헬스 체크를 실시하는 시간 간격을 의미한다. 애플리케이션을 시작하는데 시간이 오래 걸리는 경우 필요하다.

이미지에 헬스체크가 정의되지 않았다면 컴포즈 파일에서 정의하는 방법도 있다. `test` 필드가 헬스 체크를 위해 실행하는 명령이다.

모든 컨테이너에 헬스 체크를 적용하는 것뿐만 아니라 이 스크립트에서는 이미지에 디펜던시 체크가 포함되어 있다. 스크립트에는 `restart: on-failure` 설정이 있으므로 컨테이너가 예기치 않게 종료되면 컨테이너를 재시작한다. 그러나 의존 관계를 정의한 `depends_on`이 없으므로 도커 컴포즈는 컨테이너를 어떤 순서로든 실행할 수 있다. API 컨테이너의 준비가 끝나기 전에 웹 애플리케이션 컨테이너가 실행되면 디펜던시 체크가 실패해 웹 컨테이너가 종료된다. 하지만 결국 API 컨테이너도 실행될 것이므로 마지막에는 디펜던시 체크도 성공해 애플리케이션이 제대로 동작한다.

```docker
hee@yuhuijin-ui-MacBookAir numbers % docker-compose up -d     
WARN[0000] network app-net: network.external.name is deprecated in favor of network.name 
[+] Running 2/2
 ⠿ Container numbers-numbers-api-1  Started                                                                                                           0.3s
 ⠿ Container numbers-numbers-web-1  Started                                                                                                           0.4s
hee@yuhuijin-ui-MacBookAir numbers % docker container ls
CONTAINER ID   IMAGE                        COMMAND                  CREATED         STATUS                            PORTS                  NAMES
c429e2c8aa1b   diamol/ch08-numbers-web:v3   "/bin/sh -c 'dotnet …"   9 seconds ago   Up 3 seconds (health: starting)   0.0.0.0:8088->80/tcp   numbers-numbers-web-1
94ebd8b4d075   diamol/ch08-numbers-api:v3   "dotnet Numbers.Api.…"   9 seconds ago   Up 8 seconds (healthy)            0.0.0.0:8087->80/tcp   numbers-numbers-api-1
hee@yuhuijin-ui-MacBookAir numbers % docker container logs numbers-numbers-web-1
HTTPCheck: status OK, url http://numbers-api/rng, took 5068ms    // 너무 오래 걸린다.
HTTPCheck: status OK, url http://numbers-api/rng, took 32ms
warn: Microsoft.AspNetCore.DataProtection.Repositories.FileSystemXmlRepository[60]
      Storing keys in a directory '/root/.aspnet/DataProtection-Keys' that may not be persisted outside of the container. Protected data will be unavailable when container is destroyed.
warn: Microsoft.AspNetCore.DataProtection.KeyManagement.XmlKeyManager[35]
      No XML encryptor configured. Key {1ea78b6f-7b7e-44f5-994c-2c3946c6a7a7} may be persisted to storage in unencrypted form.
info: Microsoft.Hosting.Lifetime[0]
      Now listening on: http://[::]:80
info: Microsoft.Hosting.Lifetime[0]
      Application started. Press Ctrl+C to shut down.
info: Microsoft.Hosting.Lifetime[0]
      Hosting environment: Production
info: Microsoft.Hosting.Lifetime[0]
      Content root path: /app
```

의존 관계가 정의되지 않았으므로 컴포즈를 실행하면 두 컨테이너를 동시에 생성한다. API 컨테이너가 시작하는 동안 웹 애플리케이션 컨테이너의 디펜던시 체크가 실행된다.

왜 도커 컴포즈 파일에 `depends_on` 을 사용해 직접 디펜던시 체크를 하도록 하지 않는지 궁금한 독자도 있을 것이다. 그 이유는 도커 컴포즈가 디펜던시 체크를 할 수 있는 범위가 단일 서버로 제한되기 때문이다. 이에 비하면 운영 환경에서 애플리케이션을 실제 시작할 때 일어나는 상황은 이보다 훨씬 예측하기 어렵다.

# 8.5 헬스체크와 디펜던시 체크로 복원력 있는 애플리케이션을 만들 수 있는 이유

여러개의 요소로 구성된 분산 시스템으로 동작하는 애플리케이션은 유연성과 기민성 면에서 뛰어나다. 그러나 반대 급부로 관리가 그만큼 어려워진다. 구성 요소 간의 복잡한 의존 관계를 보면, 이들 의존 관계를 각 구성 요소를 시작하는 순서에 반영해 모델링하고 싶은 유혹에 빠지기 쉽다. 하지만 이 방법은 그리 현명한 방법이 아니다.

물리 서버가 한 대뿐인 환경이라면 도커 컴포즈에 웹 컨테이너보다 API 컨테이너를 먼저 실행시키라고 지시할 수 있다. 그러면 이 순서대로 실제로 컨테이너가 실행된다. 나의 운영 환경에서는 10여 대의 서버에서 쿠버네티스를 운영하는데, 이 클러스터에서 20여 개의 API 컨테이너와 50여 개의 웹 애플리케이션 컨테이너를 실행한다. 이 애플리케이션의 시작 절차를 설계한다면 어떻게 해야 할까? 웹 애플리케이션 컨테이너 50개 보다 API 컨테이너 20개를 먼저 실행해야 할까? 20개의 API 컨테이너 중 19개는 무사히 실행됐는데 마지막 한 개가 실행이 늦어져 5분이나 걸렸다면 어떻게 될까? 웹 애플리케이션 컨테이너가 하나도 실행되지 않았으므로 애플리케이션이 동작중이라 할 수 없다. 하지만 API 컨테이너가 하나 부족하더라도 50개의 웹 애플리케이션 컨테이너를 실행하는 데는 문제가 없다.

디펜던시 체크와 헬스 체크가 활약하는 부분이 바로 이 지점이다. 디펜던시 체크와 헬스 체크를 도입하면 처음부터 플랫폼이 실행 순서를 보장하게 할 필요가 없다. 가능한 한 빨리 컨테이너를 실행하면 된다. 일부 컨테이너가 의존 관계를 만족하지 못한 상태라면 재실행되거나 다른 컨테이너로 교체될 것이다. 이런 방법이면 대규모 애플리케이션의 경우 완전 동작 상태가 되는 데 몇 분 정도가 걸린다. 하지만 그동안에도 애플리케이션이 동작하며 요청을 처리할 수 있다.

애플리케이션의 자기 수복이란 일시적인 오류를 플랫폼이 해소해 주는 것이다. 애플리케이션에 메모리 누수를 일으키는 까다로운 버그가 있더라도 플랫폼에서 해당 컨테이너를 메모리를 잃지 않은 새 컨테이너로 대체하면 된다. 버그를 수정한 것은 아니지만 애플리케이션은 계속 동작할 수 있다.

하지만 헬스 체크와 디펜던시 체크에 주의가 필요하다. 헬스 체크는 주기적으로 자주 실행되므로, 시스템에 부하를 주는 내용이어서는 안된다. 자원을 너무 많이 소모하지 않으면서 애플리케이션이 실질적으로 동작 중인지 검증할 수 있는 핵심적인 부분을 테스트 해야 한다. 디펜던시 체크는 애플리케이션 시작 시에만 실행된다. 그러므로 테스트에 소모되는 리소스에 너무 크게 신경 쓸 필요는 없다. 하지만 테스트 대상이 빠짐없이 정확하도록 주의해야 한다. 디펜던시 체크에서 누락된 의존 관계가 있고 이 문제를 플랫폼이 해결하지 못한다면 애플리케이션에도 문제가 생길 것이다.